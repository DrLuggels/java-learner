export const theory = [
  { title: 'Was ist eine Exception?', content: 'Eine Exception ist ein Ereignis, das den normalen Programmfluss unterbricht. Java nutzt Exceptions für die Fehlerbehandlung statt Fehlercodes.' },
  { title: 'Exception-Hierarchie', content: 'Throwable ist die Oberklasse. Darunter: Error (schwere Fehler, nicht fangen) und Exception. Unter Exception liegt RuntimeException (unchecked). Alle anderen Exceptions sind checked.', code: 'Throwable\n├── Error (OutOfMemoryError)\n└── Exception (checked)\n    └── RuntimeException (unchecked)\n        ├── NullPointerException\n        ├── IndexOutOfBoundsException\n        └── IllegalArgumentException' },
  { title: 'Checked vs Unchecked', content: 'Checked Exceptions müssen behandelt (try-catch) oder deklariert (throws) werden – z.B. IOException. Unchecked Exceptions (RuntimeException) müssen nicht behandelt werden – z.B. NullPointerException.' },
  { title: 'try-catch-finally', content: 'try enthält den riskanten Code. catch fängt die Exception. finally wird immer ausgeführt, egal ob Exception oder nicht.', code: 'try {\n    int x = 10 / 0;\n} catch (ArithmeticException e) {\n    System.out.println("Fehler: " + e.getMessage());\n} finally {\n    System.out.println("Immer ausgeführt");\n}' },
  { title: 'throw und throws', content: 'throw wirft eine Exception aktiv. throws deklariert in der Methodensignatur, dass eine Exception geworfen werden kann.', code: 'void pruefen(int alter) throws Exception {\n    if (alter < 0) {\n        throw new Exception("Ungültiges Alter");\n    }\n}' },
  { title: 'Eigene Exceptions erstellen', content: 'Man kann eigene Exception-Klassen erstellen, indem man Exception (checked) oder RuntimeException (unchecked) erweitert.', code: 'class AlterException extends Exception {\n    private int alter;\n    AlterException(String msg, int alter) {\n        super(msg);\n        this.alter = alter;\n    }\n    int getAlter() { return alter; }\n}' },
  { title: 'Multi-catch', content: 'Seit Java 7 kann man mehrere Exception-Typen in einem catch-Block fangen.', code: 'try {\n    // Code\n} catch (IOException | SQLException e) {\n    System.out.println("Fehler: " + e.getMessage());\n}' }
];

export const questions = [
  { id: 'm11q01', type: 'mc', question: 'Was ist der Unterschied zwischen Checked und Unchecked Exceptions?', options: ['Checked müssen behandelt oder deklariert werden, Unchecked nicht', 'Unchecked müssen immer gefangen werden', 'Es gibt keinen Unterschied', 'Checked sind schwerwiegender'], answer: 'Checked müssen behandelt oder deklariert werden, Unchecked nicht', explanation: 'Checked Exceptions erzwingen Behandlung durch den Compiler. Unchecked (RuntimeException) nicht.' },
  { id: 'm11q02', type: 'mc', question: 'Was macht der finally-Block?', options: ['Wird immer ausgeführt, egal ob Exception aufgetreten ist oder nicht', 'Wird nur bei Exceptions ausgeführt', 'Wird nur ohne Exception ausgeführt', 'Ersetzt den catch-Block'], answer: 'Wird immer ausgeführt, egal ob Exception aufgetreten ist oder nicht', explanation: 'finally wird garantiert ausgeführt – ideal für Aufräumarbeiten wie Ressourcen schließen.' },
  { id: 'm11q03', type: 'mc', question: 'Wie erstellt man eine eigene checked Exception?', options: ['class MeineException extends Exception { }', 'class MeineException extends RuntimeException { }', 'class MeineException implements Exception { }', 'class MeineException extends Error { }'], answer: 'class MeineException extends Exception { }', explanation: 'Eigene checked Exceptions erweitern Exception. Für unchecked erweitert man RuntimeException.' },
  { id: 'm11q04', type: 'mc', question: 'Was passiert, wenn eine Exception nicht gefangen wird?', options: ['Das Programm bricht mit einem Stacktrace ab', 'Die Exception wird ignoriert', 'Das Programm läuft normal weiter', 'Der Compiler gibt eine Warnung aus'], answer: 'Das Programm bricht mit einem Stacktrace ab', explanation: 'Nicht gefangene Exceptions propagieren nach oben. Wenn sie nirgends gefangen werden, bricht das Programm ab.' },
  { id: 'm11q05', type: 'truefalse', question: 'RuntimeException ist eine checked Exception.', options: ['Wahr', 'Falsch'], answer: 'Falsch', explanation: 'RuntimeException und alle Unterklassen sind unchecked – der Compiler erzwingt keine Behandlung.' },
  { id: 'm11q06', type: 'truefalse', question: 'Der finally-Block wird auch ausgeführt, wenn im try-Block ein return steht.', options: ['Wahr', 'Falsch'], answer: 'Wahr', explanation: 'finally wird auch bei return, break oder continue im try-Block ausgeführt.' },
  { id: 'm11q07', type: 'mc', question: 'Was bedeutet throws in einer Methodensignatur?', options: ['Die Methode kann diese Exception werfen und der Aufrufer muss sie behandeln', 'Die Methode fängt die Exception', 'Die Methode erstellt eine neue Exception-Klasse', 'Die Methode ignoriert Exceptions'], answer: 'Die Methode kann diese Exception werfen und der Aufrufer muss sie behandeln', explanation: 'throws deklariert, welche checked Exceptions eine Methode werfen kann. Der Aufrufer muss sie behandeln.' },
  { id: 'm11q08', type: 'mc', question: 'Was ist der Unterschied zwischen throw und throws?', options: ['throw wirft eine Exception, throws deklariert sie in der Methodensignatur', 'throw deklariert, throws wirft', 'Beides ist identisch', 'throw ist für checked, throws für unchecked'], answer: 'throw wirft eine Exception, throws deklariert sie in der Methodensignatur', explanation: 'throw new Exception() wirft aktiv. void methode() throws Exception deklariert die Möglichkeit.' },
  { id: 'm11q09', type: 'mc', question: 'Ist try ohne catch erlaubt?', options: ['Ja, aber nur zusammen mit finally', 'Nein, catch ist immer erforderlich', 'Ja, ohne Einschränkungen', 'Nein, try ist optional'], answer: 'Ja, aber nur zusammen mit finally', explanation: 'try muss entweder catch oder finally (oder beides) haben. try-finally ohne catch ist erlaubt.' },
  { id: 'm11q10', type: 'mc', question: 'Was ist die Ausgabe?', code: 'class GeldException extends Exception {\n    private double betrag;\n    GeldException(String msg, double betrag) {\n        super(msg);\n        this.betrag = betrag;\n    }\n    double getBetrag() { return betrag; }\n}\ntry {\n    throw new GeldException("Zu wenig", 9.99);\n} catch (GeldException e) {\n    System.out.println(e.getBetrag());\n}', options: ['9.99', 'Zu wenig', 'null', 'Kompilierfehler'], answer: '9.99', explanation: 'Die eigene Exception speichert den Betrag. getBetrag() gibt 9.99 zurück.' },
  { id: 'm11q11', type: 'mc', question: 'Was ist die Ausgabe?', code: 'try {\n    System.out.print("A");\n    int x = 1 / 0;\n    System.out.print("B");\n} catch (ArithmeticException e) {\n    System.out.print("C");\n} finally {\n    System.out.print("D");\n}', options: ['ACD', 'ABCD', 'AD', 'ACD + Exception'], answer: 'ACD', explanation: '"A" wird gedruckt. Division durch 0 wirft Exception → "B" wird übersprungen. catch druckt "C", finally druckt "D".' },
  { id: 'm11q12', type: 'truefalse', question: 'NullPointerException ist eine checked Exception.', options: ['Wahr', 'Falsch'], answer: 'Falsch', explanation: 'NullPointerException erbt von RuntimeException und ist daher unchecked.' }
];
