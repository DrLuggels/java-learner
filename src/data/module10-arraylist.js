export const theory = [
  { title: 'ArrayList erstellen', content: 'Eine ArrayList ist eine dynamische Liste aus dem java.util-Paket. Sie wächst automatisch und speichert nur Objekte (keine primitiven Typen).', code: 'import java.util.ArrayList;\nArrayList<String> liste = new ArrayList<>();\nliste.add("Hallo");\nliste.add("Welt");' },
  { title: 'Wichtige Methoden', content: 'add(e) – Element hinzufügen, get(i) – Element an Index, size() – Anzahl Elemente, remove(i) – Element entfernen, contains(e) – Enthält Element?, isEmpty() – Liste leer?, indexOf(e) – Index von Element (-1 wenn nicht vorhanden).', code: 'liste.add("A");\nString s = liste.get(0);  // "A"\nint n = liste.size();     // 1\nliste.remove(0);\nboolean b = liste.contains("A"); // false' },
  { title: 'ArrayList vs Array', content: 'Array: feste Größe, primitive Typen erlaubt, [] Syntax. ArrayList: dynamische Größe, nur Objekte, Methodenzugriff. ArrayList ist flexibler, Array ist performanter.' },
  { title: 'Autoboxing', content: 'Java konvertiert automatisch zwischen primitiven Typen und Wrapper-Klassen: int ↔ Integer, double ↔ Double, boolean ↔ Boolean. ArrayList<int> ist nicht möglich, nur ArrayList<Integer>.', code: 'ArrayList<Integer> zahlen = new ArrayList<>();\nzahlen.add(42);        // Autoboxing: int → Integer\nint wert = zahlen.get(0); // Unboxing: Integer → int' },
  { title: 'List.of() und Arrays.asList()', content: 'List.of() erstellt eine unveränderliche Liste. Arrays.asList() erstellt eine Liste fester Größe aus einem Array. Beide können nicht vergrößert oder verkleinert werden.', code: 'List<String> fest = List.of("A", "B", "C");\n// fest.add("D"); → UnsupportedOperationException' },
  { title: 'Iteration über ArrayList', content: 'Man kann mit for-each, klassischem for oder Iterator über eine ArrayList iterieren.', code: 'for (String s : liste) {\n    System.out.println(s);\n}\nfor (int i = 0; i < liste.size(); i++) {\n    System.out.println(liste.get(i));\n}' },
  { title: 'ArrayList als Klassenattribut', content: 'ArrayLists werden häufig als Attribute in Klassen verwendet, um 1:n-Beziehungen abzubilden (z.B. Kurs hat viele Studenten).', code: 'class Kurs {\n    private ArrayList<String> studenten;\n    Kurs() {\n        studenten = new ArrayList<>();\n    }\n    void hinzufuegen(String s) {\n        studenten.add(s);\n    }\n}' }
];

export const questions = [
  { id: 'm10q01', type: 'mc', question: 'Wie erstellt man eine ArrayList für Strings?', options: ['ArrayList<String> l = new ArrayList<>()', 'ArrayList l = new String[10]', 'String[] l = new ArrayList()', 'List l = new Array<String>()'], answer: 'ArrayList<String> l = new ArrayList<>()', explanation: 'Die korrekte Syntax nutzt Generics mit dem Diamant-Operator <>.' },
  { id: 'm10q02', type: 'mc', question: 'Was ist der Hauptunterschied zwischen ArrayList und Array?', options: ['ArrayList hat dynamische Größe und speichert nur Objekte', 'Array ist langsamer als ArrayList', 'ArrayList kann primitive Typen speichern', 'Es gibt keinen Unterschied'], answer: 'ArrayList hat dynamische Größe und speichert nur Objekte', explanation: 'Arrays haben feste Größe und können primitive Typen speichern. ArrayLists wachsen dynamisch, brauchen aber Wrapper-Klassen.' },
  { id: 'm10q03', type: 'mc', question: 'Was macht Autoboxing in Java?', options: ['Konvertiert automatisch primitive Typen in Wrapper-Objekte', 'Packt Objekte in Arrays', 'Erstellt automatisch ArrayLists', 'Konvertiert Strings in Zahlen'], answer: 'Konvertiert automatisch primitive Typen in Wrapper-Objekte', explanation: 'Autoboxing: int → Integer, double → Double usw. geschieht automatisch.' },
  { id: 'm10q04', type: 'mc', question: 'Was passiert bei liste.get(0) wenn die Liste leer ist?', options: ['IndexOutOfBoundsException', 'null wird zurückgegeben', 'Kompilierfehler', 'Es wird 0 zurückgegeben'], answer: 'IndexOutOfBoundsException', explanation: 'Bei Zugriff auf einen ungültigen Index wirft ArrayList eine IndexOutOfBoundsException.' },
  { id: 'm10q05', type: 'mc', question: 'Ist ArrayList<int> erlaubt?', options: ['Nein, man muss ArrayList<Integer> verwenden', 'Ja, int ist ein gültiger Typ', 'Ja, aber nur in Java 17+', 'Nein, man braucht ArrayList<Number>'], answer: 'Nein, man muss ArrayList<Integer> verwenden', explanation: 'Generics erfordern Referenztypen. Primitive Typen wie int sind nicht erlaubt – man nutzt die Wrapper-Klasse Integer.' },
  { id: 'm10q06', type: 'mc', question: 'Was gibt liste.size() zurück?', options: ['Die Anzahl der Elemente in der Liste', 'Die maximale Kapazität', 'Den Index des letzten Elements', 'Die Speichergröße in Bytes'], answer: 'Die Anzahl der Elemente in der Liste', explanation: 'size() gibt die aktuelle Anzahl der gespeicherten Elemente zurück.' },
  { id: 'm10q07', type: 'mc', question: 'Was gibt liste.contains("X") zurück?', options: ['true wenn "X" in der Liste ist, sonst false', 'Den Index von "X"', 'Das Element "X"', 'Eine Exception wenn "X" nicht existiert'], answer: 'true wenn "X" in der Liste ist, sonst false', explanation: 'contains() prüft mit equals(), ob das Element vorhanden ist und gibt einen boolean zurück.' },
  { id: 'm10q08', type: 'mc', question: 'Was macht liste.remove(0)?', options: ['Entfernt das erste Element und verschiebt die restlichen', 'Setzt das erste Element auf null', 'Entfernt alle Elemente', 'Entfernt das Element mit dem Wert 0'], answer: 'Entfernt das erste Element und verschiebt die restlichen', explanation: 'remove(int index) entfernt das Element am angegebenen Index. Nachfolgende Elemente rücken auf.' },
  { id: 'm10q09', type: 'truefalse', question: 'Eine mit List.of(1, 2, 3) erstellte Liste kann verändert werden (z.B. add/remove).', options: ['Wahr', 'Falsch'], answer: 'Falsch', explanation: 'List.of() erstellt eine unveränderliche (immutable) Liste. Jede Änderung führt zu UnsupportedOperationException.' },
  { id: 'm10q10', type: 'truefalse', question: 'Eine ArrayList kann null als Element enthalten.', options: ['Wahr', 'Falsch'], answer: 'Wahr', explanation: 'ArrayList erlaubt null-Werte als Elemente, im Gegensatz zu List.of().' },
  { id: 'm10q11', type: 'mc', question: 'Was ist die Ausgabe?', code: 'ArrayList<String> l = new ArrayList<>();\nl.add("A");\nl.add("B");\nl.add("C");\nl.add(1, "X");\nSystem.out.println(l);', options: ['[A, X, B, C]', '[A, B, C, X]', '[X, A, B, C]', '[A, B, X, C]'], answer: '[A, X, B, C]', explanation: 'add(1, "X") fügt "X" an Index 1 ein und verschiebt die nachfolgenden Elemente.' },
  { id: 'm10q12', type: 'mc', question: 'Was ist die Ausgabe?', code: 'class Team {\n    ArrayList<String> mitglieder = new ArrayList<>();\n    void add(String name) {\n        mitglieder.add(name);\n    }\n    int groesse() {\n        return mitglieder.size();\n    }\n}\nTeam t = new Team();\nt.add("Anna");\nt.add("Ben");\nSystem.out.println(t.groesse());', options: ['2', '0', '1', 'Kompilierfehler'], answer: '2', explanation: 'Zwei Mitglieder wurden hinzugefügt, also gibt groesse() den Wert 2 zurück.' },
  { id: 'm10q13', type: 'mc', question: 'Was gibt indexOf() zurück, wenn das Element nicht vorhanden ist?', options: ['-1', '0', 'null', 'Eine Exception'], answer: '-1', explanation: 'indexOf() gibt -1 zurück, wenn das Element nicht in der Liste gefunden wird.' },
  { id: 'm10q14', type: 'truefalse', question: 'isEmpty() gibt true zurück bei einer frisch erstellten ArrayList (ohne add-Aufrufe).', options: ['Wahr', 'Falsch'], answer: 'Wahr', explanation: 'Eine neue ArrayList hat 0 Elemente, daher gibt isEmpty() true zurück.' },
  { id: 'm10q15', type: 'mc', question: 'Was ist die Ausgabe?', code: 'ArrayList<Integer> z = new ArrayList<>();\nz.add(10);\nz.add(20);\nz.add(30);\nz.add(5);\nint count = 0;\nfor (int n : z) {\n    if (n > 15) count++;\n}\nSystem.out.println(count);', options: ['2', '3', '1', '0'], answer: '2', explanation: 'Nur 20 und 30 sind größer als 15. Also ist count = 2.' }
];
