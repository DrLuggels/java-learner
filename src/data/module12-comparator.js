export const theory = [
  { title: 'Comparable<T> Interface', content: 'Comparable definiert die natürliche Ordnung einer Klasse. Die Klasse implementiert compareTo(T other) selbst. Wird von Collections.sort() und Arrays.sort() automatisch genutzt.', code: 'class Student implements Comparable<Student> {\n    String name;\n    int note;\n    public int compareTo(Student other) {\n        return Integer.compare(this.note, other.note);\n    }\n}' },
  { title: 'compareTo() Rückgabewerte', content: 'Negativ (z.B. -1): aktuelles Objekt ist kleiner. 0: beide sind gleich. Positiv (z.B. 1): aktuelles Objekt ist größer. Merke: "this minus other" für aufsteigende Sortierung.' },
  { title: 'Comparator<T> Interface', content: 'Comparator definiert eine externe, benutzerdefinierte Sortierung. Er wird als separates Objekt erstellt und an sort() übergeben. Nützlich für alternative Sortierungen.', code: 'class NameComparator implements Comparator<Student> {\n    public int compare(Student a, Student b) {\n        return a.name.compareTo(b.name);\n    }\n}' },
  { title: 'Collections.sort()', content: 'Collections.sort(liste) nutzt Comparable (natürliche Ordnung). Collections.sort(liste, comparator) nutzt den übergebenen Comparator.', code: 'ArrayList<Student> liste = new ArrayList<>();\nCollections.sort(liste);            // Comparable\nCollections.sort(liste, new NameComparator()); // Comparator' },
  { title: 'Absteigende Sortierung', content: 'Für absteigende Sortierung kann man die Vergleichslogik umdrehen (other - this), oder Comparator.reversed() verwenden.', code: '// Variante 1: Umdrehen\npublic int compareTo(Student other) {\n    return Integer.compare(other.note, this.note);\n}\n// Variante 2: reversed()\nCollections.sort(liste, new NoteComparator().reversed());' },
  { title: 'Multi-Level-Sortierung', content: 'Bei gleichen Werten kann man nach einem zweiten Kriterium sortieren. Erst das primäre Kriterium prüfen, bei 0 das sekundäre nutzen.', code: 'public int compare(Student a, Student b) {\n    int result = Integer.compare(a.note, b.note);\n    if (result == 0) {\n        result = a.name.compareTo(b.name);\n    }\n    return result;\n}' }
];

export const questions = [
  { id: 'm12q01', type: 'mc', question: 'Was ist der Unterschied zwischen Comparable und Comparator?', options: ['Comparable: natürliche Ordnung in der Klasse selbst; Comparator: externe benutzerdefinierte Ordnung', 'Es gibt keinen Unterschied', 'Comparable ist für Strings, Comparator für Zahlen', 'Comparator ist veraltet'], answer: 'Comparable: natürliche Ordnung in der Klasse selbst; Comparator: externe benutzerdefinierte Ordnung', explanation: 'Comparable wird in der Klasse selbst implementiert (compareTo). Comparator ist ein externes Objekt (compare).' },
  { id: 'm12q02', type: 'mc', question: 'Was bedeutet es, wenn compareTo() einen negativen Wert zurückgibt?', options: ['Das aktuelle Objekt (this) ist kleiner als das andere', 'Das aktuelle Objekt ist größer', 'Beide sind gleich', 'Ein Fehler ist aufgetreten'], answer: 'Das aktuelle Objekt (this) ist kleiner als das andere', explanation: 'Negativ = this < other, 0 = gleich, Positiv = this > other.' },
  { id: 'm12q03', type: 'mc', question: 'Wie sortiert man eine Liste absteigend?', options: ['Rückgabewert umdrehen (other vs this) oder Comparator.reversed() nutzen', 'Collections.sortDesc() aufrufen', 'ArrayList.reverse() vor dem Sortieren', 'Negative Werte in die Liste einfügen'], answer: 'Rückgabewert umdrehen (other vs this) oder Comparator.reversed() nutzen', explanation: 'Man dreht die Vergleichslogik um oder nutzt die reversed()-Methode des Comparators.' },
  { id: 'm12q04', type: 'mc', question: 'Warum braucht man Comparator, wenn es schon Comparable gibt?', options: ['Für alternative Sortierungen ohne die Klasse zu ändern', 'Comparable funktioniert nicht mit Collections.sort()', 'Comparator ist schneller', 'Man braucht Comparator nicht'], answer: 'Für alternative Sortierungen ohne die Klasse zu ändern', explanation: 'Eine Klasse hat nur eine natürliche Ordnung (Comparable). Für weitere Sortierungen nutzt man Comparator.' },
  { id: 'm12q05', type: 'mc', question: 'Welche Methode definiert das Comparable-Interface?', options: ['compareTo(T other)', 'compare(T a, T b)', 'equals(Object o)', 'sort(T a, T b)'], answer: 'compareTo(T other)', explanation: 'Comparable definiert die Methode compareTo(), die das aktuelle Objekt mit einem anderen vergleicht.' },
  { id: 'm12q06', type: 'mc', question: 'Welche Methode definiert das Comparator-Interface?', options: ['compare(T a, T b)', 'compareTo(T other)', 'sort(T a, T b)', 'order(T a, T b)'], answer: 'compare(T a, T b)', explanation: 'Comparator definiert compare(), die zwei externe Objekte vergleicht.' },
  { id: 'm12q07', type: 'mc', question: 'Was nutzt Collections.sort() zur Sortierung?', options: ['Comparable der Elemente oder einen übergebenen Comparator', 'Nur Comparator', 'Nur Comparable', 'Die hashCode()-Methode'], answer: 'Comparable der Elemente oder einen übergebenen Comparator', explanation: 'sort(list) nutzt Comparable, sort(list, comparator) nutzt den übergebenen Comparator.' },
  { id: 'm12q08', type: 'mc', question: 'Was bedeutet ein Rückgabewert von 0 bei compareTo()?', options: ['Beide Objekte sind gleich (bezüglich der Sortierung)', 'Das aktuelle Objekt ist kleiner', 'Ein Fehler ist aufgetreten', 'Die Sortierung wird abgebrochen'], answer: 'Beide Objekte sind gleich (bezüglich der Sortierung)', explanation: 'Rückgabewert 0 bedeutet, dass beide Objekte in der Sortierreihenfolge gleichwertig sind.' },
  { id: 'm12q09', type: 'truefalse', question: 'Comparator ist ein funktionales Interface (hat nur eine abstrakte Methode).', options: ['Wahr', 'Falsch'], answer: 'Wahr', explanation: 'Comparator hat nur die abstrakte Methode compare() und ist damit ein funktionales Interface (nutzbar mit Lambdas).' },
  { id: 'm12q10', type: 'mc', question: 'Was gibt Integer.compare(3, 5) zurück?', options: ['Einen negativen Wert', 'Einen positiven Wert', '0', 'Eine Exception'], answer: 'Einen negativen Wert', explanation: '3 < 5, also gibt Integer.compare() einen negativen Wert zurück.' },
  { id: 'm12q11', type: 'mc', question: 'Was ist die korrekte Sortierreihenfolge?', code: 'class Produkt implements Comparable<Produkt> {\n    String name;\n    double preis;\n    Produkt(String n, double p) { name = n; preis = p; }\n    public int compareTo(Produkt o) {\n        return Double.compare(this.preis, o.preis);\n    }\n}\n// Produkte: Apfel(1.5), Brot(2.0), Milch(0.99)\nCollections.sort(liste);', options: ['Milch, Apfel, Brot (nach Preis aufsteigend)', 'Brot, Apfel, Milch (nach Preis absteigend)', 'Apfel, Brot, Milch (alphabetisch)', 'Milch, Brot, Apfel (zufällig)'], answer: 'Milch, Apfel, Brot (nach Preis aufsteigend)', explanation: 'compareTo vergleicht nach Preis aufsteigend: 0.99 < 1.5 < 2.0.' },
  { id: 'm12q12', type: 'mc', question: 'Was ist die Ausgabe?', code: 'class LangeComparator implements Comparator<String> {\n    public int compare(String a, String b) {\n        return Integer.compare(a.length(), b.length());\n    }\n}\nArrayList<String> w = new ArrayList<>();\nw.add("Hi"); w.add("Hallo"); w.add("Hey");\nCollections.sort(w, new LangeComparator());\nSystem.out.println(w);', options: ['[Hi, Hey, Hallo]', '[Hallo, Hey, Hi]', '[Hey, Hi, Hallo]', '[Hallo, Hi, Hey]'], answer: '[Hi, Hey, Hallo]', explanation: 'Sortiert nach Stringlänge aufsteigend: Hi(2), Hey(3), Hallo(5).' },
  { id: 'm12q13', type: 'mc', question: 'Was ist die Ausgabe?', code: 'ArrayList<Integer> z = new ArrayList<>();\nz.add(5); z.add(1); z.add(3);\nCollections.sort(z, (a, b) -> Integer.compare(b, a));\nSystem.out.println(z);', options: ['[5, 3, 1]', '[1, 3, 5]', '[3, 1, 5]', 'Kompilierfehler'], answer: '[5, 3, 1]', explanation: 'Der Lambda-Comparator vergleicht b mit a (umgekehrt), also absteigende Sortierung.' },
  { id: 'm12q14', type: 'truefalse', question: 'Die Klasse String implementiert das Comparable-Interface.', options: ['Wahr', 'Falsch'], answer: 'Wahr', explanation: 'String implementiert Comparable<String>. compareTo() vergleicht Strings lexikographisch.' },
  { id: 'm12q15', type: 'mc', question: 'Was ist die Ausgabe?', code: 'ArrayList<String> namen = new ArrayList<>();\nnamen.add("Charlie");\nnamen.add("Anna");\nnamen.add("Bob");\nCollections.sort(namen);\nCollections.sort(namen, Comparator.reverseOrder());\nSystem.out.println(namen);', options: ['[Charlie, Bob, Anna]', '[Anna, Bob, Charlie]', '[Bob, Anna, Charlie]', 'Kompilierfehler'], answer: '[Charlie, Bob, Anna]', explanation: 'Erst wird aufsteigend sortiert, dann mit reverseOrder() absteigend: Charlie, Bob, Anna.' }
];
