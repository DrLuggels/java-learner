export const theory = [
  {
    title: 'Klasse vs. Objekt',
    content: 'Eine Klasse ist ein BAUPLAN (Blueprint), ein Objekt ist eine konkrete INSTANZ, die nach diesem Bauplan erstellt wurde.\n\nAnalogie: Eine Klasse ist wie eine Ausstechform fuer Plaetzchen. Die Ausstechform definiert die Form, aber ist selbst kein Plaetzchen. Jedes Plaetzchen, das du damit ausstichst, ist ein Objekt (eine Instanz).\n\nWeitere Analogie: Die Klasse "Auto" beschreibt, dass ein Auto eine Marke, eine Farbe und eine Geschwindigkeit hat. Das konkrete rote BMW-Auto in deiner Garage ist ein OBJEKT der Klasse Auto.\n\nAus EINER Klasse kannst du BELIEBIG VIELE Objekte erstellen. Jedes Objekt hat eigene Werte fuer die Attribute.\n\nObjekte werden mit dem Schluesselwort new erstellt.'
  },
  {
    title: 'Klasse vs. Objekt - Codebeispiel',
    content: 'Hier siehst du den Unterschied zwischen Klasse (Bauplan) und Objekten (Instanzen) im Code. Die Klasse Hund definiert, dass jeder Hund einen Namen und ein Alter hat. Dann erstellen wir zwei verschiedene Hund-Objekte mit eigenen Werten.',
    code: '// Die KLASSE (Bauplan)\npublic class Hund {\n    String name;\n    int alter;\n\n    void bellen() {\n        System.out.println(name + " sagt: Wuff!");\n    }\n}\n\n// OBJEKTE erstellen (Instanzen)\nHund h1 = new Hund();  // erstes Objekt\nh1.name = "Rex";\nh1.alter = 3;\n\nHund h2 = new Hund();  // zweites Objekt\nh2.name = "Bella";\nh2.alter = 5;\n\nh1.bellen(); // "Rex sagt: Wuff!"\nh2.bellen(); // "Bella sagt: Wuff!"\n// Zwei Objekte, gleiche Klasse, verschiedene Werte!'
  },
  {
    title: 'Attribute (Instanzvariablen)',
    content: 'Attribute (auch Instanzvariablen oder Felder genannt) speichern den ZUSTAND eines Objekts. Sie werden im Klassen-Koerper deklariert, aber AUSSERHALB von Methoden.\n\nJedes Objekt hat seine EIGENE Kopie der Attribute. Wenn du bei einem Hund den Namen aenderst, bleibt der Name des anderen Hundes unveraendert.\n\nStandardwerte (wenn nicht explizit gesetzt):\n- int, long, etc.: 0\n- double, float: 0.0\n- boolean: false\n- Objekte (String, etc.): null\n\nWICHTIG: Attribute sollten PRIVATE sein (Kapselung/Encapsulation). Der Zugriff erfolgt ueber Getter und Setter. Warum? Damit niemand ungueltige Werte direkt setzen kann.',
    code: '// Attribute sollten private sein!\npublic class Student {\n    private String name;     // Standardwert: null\n    private int matrikelnr;  // Standardwert: 0\n    private double schnitt;  // Standardwert: 0.0\n    private boolean aktiv;   // Standardwert: false\n}\n\n// Jedes Objekt hat eigene Kopien:\nStudent s1 = new Student();\nStudent s2 = new Student();\n// s1.name und s2.name sind UNABHAENGIG voneinander'
  },
  {
    title: 'Methoden',
    content: 'Methoden definieren das VERHALTEN eines Objekts. Sie beschreiben, was ein Objekt TUN kann.\n\nSyntax:\nsichtbarkeit rueckgabetyp name(parameter) {\n    // Methodenkoerper\n}\n\nBeispiel: public double berechneSchnitt(int[] noten)\n- public = von ueberall aufrufbar\n- double = gibt einen double-Wert zurueck\n- berechneSchnitt = Name der Methode\n- int[] noten = Parameter\n\nvoid bedeutet: Die Methode gibt NICHTS zurueck.\nreturn beendet die Methode und gibt ggf. einen Wert zurueck. Nach return wird KEIN weiterer Code in der Methode ausgefuehrt!\n\nKonvention: Methodennamen beginnen mit Kleinbuchstabe, camelCase: berechneFlaeche(), getAlter(), istAktiv().',
    code: '// Methode ohne Rueckgabe (void)\npublic void begruessung(String name) {\n    System.out.println("Hallo " + name);\n    // kein return noetig bei void\n}\n\n// Methode mit Rueckgabe\npublic double berechneFlaeche(double r) {\n    return Math.PI * r * r;\n}\n\n// return beendet die Methode sofort!\npublic int absolut(int zahl) {\n    if (zahl >= 0) return zahl;\n    return -zahl;\n    // Hier kommt man nie hin bei positivem zahl\n}'
  },
  {
    title: 'Konstruktoren',
    content: 'Ein Konstruktor ist eine SPEZIELLE Methode, die aufgerufen wird, wenn ein Objekt mit new erstellt wird. Er dient dazu, das Objekt zu initialisieren.\n\nRegeln:\n1. Der Konstruktor hat den GLEICHEN Namen wie die Klasse\n2. Er hat KEINEN Rueckgabetyp (auch nicht void!)\n3. Er wird mit new aufgerufen: new Person("Max")\n\nDefault-Konstruktor:\n- Wenn du KEINEN Konstruktor schreibst, erstellt Java automatisch einen leeren Default-Konstruktor (ohne Parameter)\n- ACHTUNG: Sobald du IRGENDEINEN eigenen Konstruktor schreibst, verschwindet der Default-Konstruktor! Du musst ihn dann selbst schreiben, wenn du ihn brauchst.\n\nDas ist eine haeufige Klausurfalle: "Warum funktioniert new Person() nicht mehr?"',
    code: '// Klasse OHNE eigenen Konstruktor:\npublic class Tier {\n    String art;\n}\n// Java erstellt automatisch: public Tier() {}\nTier t = new Tier();  // funktioniert!\n\n// Klasse MIT eigenem Konstruktor:\npublic class Person {\n    private String name;\n\n    public Person(String name) { // eigener Konstruktor\n        this.name = name;\n    }\n}\nPerson p = new Person("Max");  // funktioniert\n// Person p2 = new Person();   // FEHLER!\n// Default-Konstruktor ist WEG!\n\n// Loesung: Beide Konstruktoren schreiben\npublic class Person {\n    private String name;\n    public Person() { this.name = "Unbekannt"; }\n    public Person(String name) { this.name = name; }\n}'
  },
  {
    title: 'Konstruktor-Ueberladung und Verkettung',
    content: 'Ueberladung: Eine Klasse kann MEHRERE Konstruktoren haben, solange sie sich in der Parameterliste unterscheiden (Anzahl oder Typen der Parameter).\n\nVerkettung mit this(): Ein Konstruktor kann einen ANDEREN Konstruktor derselben Klasse aufrufen. Dafuer benutzt man this(...).\n\nWICHTIG: this() muss die ALLERERSTE Anweisung im Konstruktor sein! Davor darf NICHTS stehen.\n\nWarum Verkettung? Um Code-Duplizierung zu vermeiden. Statt in jedem Konstruktor die gleiche Logik zu schreiben, leitet der einfachere Konstruktor an den komplexeren weiter.',
    code: 'public class Buch {\n    private String titel;\n    private String autor;\n    private int seiten;\n\n    // Konstruktor 1: Alle Parameter\n    public Buch(String titel, String autor, int seiten) {\n        this.titel = titel;\n        this.autor = autor;\n        this.seiten = seiten;\n    }\n\n    // Konstruktor 2: Nur Titel und Autor\n    public Buch(String titel, String autor) {\n        this(titel, autor, 0); // ruft Konstruktor 1 auf!\n    }\n\n    // Konstruktor 3: Nur Titel\n    public Buch(String titel) {\n        this(titel, "Unbekannt"); // ruft Konstruktor 2 auf!\n    }\n}\n\nBuch b1 = new Buch("Java", "Meier", 500);\nBuch b2 = new Buch("Java", "Meier");\nBuch b3 = new Buch("Java");'
  },
  {
    title: 'Das this-Schluesselwort',
    content: 'this ist eine Referenz auf das AKTUELLE Objekt, in dem der Code gerade ausgefuehrt wird.\n\nHauptverwendungen:\n\n1. Namenskonflikte loesen:\nWenn ein Parameter den gleichen Namen wie ein Attribut hat, "verdeckt" (shadowed) der Parameter das Attribut. Mit this.name greifst du auf das Attribut zu, mit name auf den Parameter.\n\n2. Konstruktor-Verkettung:\nthis(...) ruft einen anderen Konstruktor derselben Klasse auf.\n\n3. Aktuelles Objekt weitergeben:\nDu kannst this als Argument an andere Methoden uebergeben, z.B. liste.add(this).\n\nOhne this bei Namenskonflikt passiert ein typischer Anfaengerfehler: name = name; weist den Parameter sich selbst zu und das Attribut bleibt unveraendert!',
    code: '// Problem: Parameter verdeckt Attribut\npublic class Person {\n    private String name;\n\n    // FALSCH: name = name (Parameter = Parameter)\n    public void setName(String name) {\n        name = name; // Macht NICHTS! Attribut bleibt null!\n    }\n\n    // RICHTIG: this.name = Attribut, name = Parameter\n    public void setName(String name) {\n        this.name = name; // Attribut wird gesetzt!\n    }\n}\n\n// this als Referenz auf das aktuelle Objekt\npublic class Spieler {\n    public void registrieren(Spiel spiel) {\n        spiel.addSpieler(this); // "Fuege MICH hinzu"\n    }\n}'
  },
  {
    title: 'Getter und Setter',
    content: 'Getter und Setter sind Methoden, die den kontrollierten Zugriff auf PRIVATE Attribute ermoeglichen. Dieses Prinzip heisst Kapselung (Encapsulation).\n\nGetter: Gibt den Wert eines Attributs zurueck.\nKonvention: getAttributname() bzw. isAttributname() fuer boolean\nBeispiel: getName(), getAlter(), isAktiv()\n\nSetter: Setzt den Wert eines Attributs.\nKonvention: setAttributname(wert)\nBeispiel: setName("Max"), setAlter(25)\n\nWarum nicht einfach public Attribute?\n- Setter koennen VALIDIEREN! Z.B. Alter darf nicht negativ sein\n- Du kannst spaeter die interne Implementierung aendern, ohne dass Code von aussen angepasst werden muss\n- Du kannst Attribute als "nur lesbar" machen (nur Getter, kein Setter)',
    code: 'public class Konto {\n    private String inhaber;\n    private double kontostand;\n\n    // Getter\n    public String getInhaber() {\n        return inhaber;\n    }\n    public double getKontostand() {\n        return kontostand;\n    }\n\n    // Setter MIT Validierung!\n    public void setInhaber(String inhaber) {\n        if (inhaber != null && !inhaber.isEmpty()) {\n            this.inhaber = inhaber;\n        }\n    }\n\n    // Kein Setter fuer kontostand!\n    // -> Nur ueber Methoden aenderbar:\n    public void einzahlen(double betrag) {\n        if (betrag > 0) {\n            this.kontostand += betrag;\n        }\n    }\n}'
  },
  {
    title: 'Sichtbarkeiten (Access Modifiers)',
    content: 'Java hat vier Zugriffsebenen, die bestimmen, wer auf Attribute und Methoden zugreifen darf:\n\npublic: Von UEBERALL zugreifbar. Alle Klassen, alle Pakete.\n\nprivate: NUR innerhalb der EIGENEN Klasse. Kein Zugriff von aussen, nicht mal von Unterklassen.\n\nprotected: Innerhalb der eigenen Klasse + Unterklassen (auch in anderen Paketen) + alle Klassen im GLEICHEN Paket.\n\npackage-private (KEIN Modifier): Nur innerhalb des gleichen Pakets. Das ist der Standard, wenn du nichts schreibst.\n\nFaustregel:\n- Attribute: IMMER private\n- Methoden fuer aussen: public\n- Hilfsmethoden: private\n- Fuer Vererbung: protected\n\nUML-Notation: + = public, - = private, # = protected, ~ = package-private',
    code: 'public class Beispiel {\n    public int a;      // ueberall sichtbar\n    private int b;     // nur in dieser Klasse\n    protected int c;   // Klasse + Unterklassen + Paket\n    int d;             // nur im gleichen Paket\n}\n\n// Von einer anderen Klasse aus:\nBeispiel obj = new Beispiel();\nobj.a = 1;   // OK (public)\n// obj.b = 2; // FEHLER (private)\nobj.c = 3;   // OK wenn gleiches Paket oder Unterklasse\nobj.d = 4;   // OK wenn gleiches Paket\n\n// Typisches Muster:\npublic class Person {\n    private String name;      // Attribut: private\n    public String getName() { // Getter: public\n        return name;\n    }\n}'
  },
  {
    title: 'static - Klassenmitglieder',
    content: 'Das Schluesselwort static bedeutet: Dieses Mitglied gehoert zur KLASSE, nicht zu einzelnen Objekten.\n\nstatic Attribut:\n- Existiert nur EINMAL, egal wie viele Objekte es gibt\n- Wird von ALLEN Instanzen geteilt\n- Zugriff ueber Klassenname: Klasse.attribut\n- Beispiel: Ein Zaehler, der mitzaehlt, wie viele Objekte erstellt wurden\n\nstatic Methode:\n- Kann OHNE Objekt aufgerufen werden: Klasse.methode()\n- Hat KEIN this! Kann daher NICHT auf Instanz-Attribute zugreifen!\n- Beispiel: Math.sqrt(), Integer.parseInt()\n\nWICHTIG fuer die Klausur:\nAus einer statischen Methode kannst du NICHT auf nicht-statische Attribute oder Methoden zugreifen! Das ist ein sehr haeufiger Fehler.',
    code: '// static Attribut: wird von allen Objekten geteilt\npublic class Auto {\n    private String marke;           // Instanz-Attribut\n    private static int anzahl = 0;  // Klassen-Attribut\n\n    public Auto(String marke) {\n        this.marke = marke;\n        anzahl++;  // bei jedem neuen Auto\n    }\n\n    // static Methode: ohne Objekt aufrufbar\n    public static int getAnzahl() {\n        return anzahl;       // OK: static auf static\n        // return marke;     // FEHLER! marke ist nicht static\n    }\n}\n\nnew Auto("BMW");\nnew Auto("VW");\nSystem.out.println(Auto.getAnzahl()); // 2\n// Aufruf ueber KLASSENNAME, nicht ueber Objekt!'
  },
  {
    title: 'Static ArrayList Pattern (KLAUSURRELEVANT!)',
    content: 'Ein sehr wichtiges Muster fuer die Klausur! Damit werden ALLE erstellten Instanzen einer Klasse in einer statischen Liste gespeichert.\n\nDas Muster besteht aus 3 Teilen:\n1. Eine static ArrayList als Klassenattribut\n2. Im Konstruktor: this zur Liste hinzufuegen\n3. Eine static Methode, um die Liste abzurufen\n\nWarum?\n- Du kannst jederzeit auf ALLE erstellten Objekte zugreifen\n- Nuetzlich fuer Berechnungen ueber alle Instanzen (z.B. Durchschnitt)\n- Haeufiges Klausur-Muster!\n\nMerke: Die ArrayList ist static (gehoert zur Klasse), aber die Objekte darin sind normale Instanzen. this im Konstruktor verweist auf das gerade erstellte Objekt.',
    code: 'import java.util.ArrayList;\n\npublic class Student {\n    private static ArrayList<Student> alle = new ArrayList<>();\n    private String name;\n    private double schnitt;\n\n    public Student(String name, double schnitt) {\n        this.name = name;\n        this.schnitt = schnitt;\n        alle.add(this); // DIESES Objekt zur Liste!\n    }\n\n    public static ArrayList<Student> getAlle() {\n        return alle;\n    }\n\n    // Beispiel: Durchschnitt ALLER Studenten\n    public static double gesamtSchnitt() {\n        double summe = 0;\n        for (Student s : alle) {\n            summe += s.schnitt;\n        }\n        return summe / alle.size();\n    }\n}\n\nnew Student("Max", 1.7);\nnew Student("Anna", 1.3);\nSystem.out.println(Student.getAlle().size()); // 2\nSystem.out.println(Student.gesamtSchnitt()); // 1.5'
  },
  {
    title: 'toString() ueberschreiben',
    content: 'Jede Klasse in Java erbt die Methode toString() von Object. Die Standard-Implementierung gibt den Klassennamen und eine Speicheradresse zurueck (z.B. Person@1b6d3586) -- nicht hilfreich!\n\nDu solltest toString() UEBERSCHREIBEN, um eine lesbare Darstellung zu liefern.\n\nWann wird toString() automatisch aufgerufen?\n- Bei System.out.println(objekt)\n- Bei String-Verkettung: "Text " + objekt\n\nVerwende die @Override-Annotation:\n- Macht klar, dass die Methode ueberschrieben wird\n- Compiler prueft, ob Signatur korrekt ist\n- Fehlervermeidung!\n\nTipp: Nutze String.format() fuer uebersichtliche Formatierung.',
    code: 'public class Person {\n    private String name;\n    private int alter;\n\n    public Person(String name, int alter) {\n        this.name = name;\n        this.alter = alter;\n    }\n\n    // OHNE Override:\n    // System.out.println(p) -> "Person@1b6d3586"\n\n    @Override\n    public String toString() {\n        return String.format("Person{name=\'%s\', alter=%d}",\n                             name, alter);\n    }\n}\n\nPerson p = new Person("Max", 25);\nSystem.out.println(p);\n// Ausgabe: Person{name=\'Max\', alter=25}\n\n// Automatisch bei String-Verkettung:\nString info = "Daten: " + p;\n// info = "Daten: Person{name=\'Max\', alter=25}"'
  }
];
