export const theory = [
  {
    title: 'Abstrakte Klassen',
    content:
      'Eine abstrakte Klasse ist eine Klasse, die NICHT direkt instanziiert werden kann.\nMan kann also KEIN new AbstrakteKlasse() schreiben!\n\nWann braucht man das? Wenn eine Klasse als GEMEINSAME BASIS dienen soll, aber selbst kein vollstaendiges Objekt darstellt.\n\nBeispiel: "Tier" ist ein abstrakter Begriff. Es gibt kein "Tier an sich". Es gibt Hunde, Katzen, Voegel -- aber kein generisches Tier. Trotzdem haben alle Tiere gemeinsame Eigenschaften (atmen, fressen).\n\nEine abstrakte Klasse kann enthalten:\n- Abstrakte Methoden (OHNE Body -- Unterklassen MUESSEN implementieren)\n- Konkrete Methoden (MIT Body -- werden vererbt)\n- Attribute/Felder (ganz normal)\n- Konstruktoren (werden ueber super() von Unterklassen aufgerufen)\n\nDie abstrakte Klasse ist also eine Mischung: Sie gibt einiges vor (konkrete Methoden) und zwingt Unterklassen, den Rest zu implementieren (abstrakte Methoden).',
    code:
      'public abstract class Tier {\n    protected String name;\n\n    // Konstruktor (wird von Unterklassen via super() aufgerufen)\n    public Tier(String name) {\n        this.name = name;\n    }\n\n    // Abstrakte Methode: KEIN Body, endet mit ;\n    // Jede konkrete Unterklasse MUSS diese implementieren!\n    public abstract void sprechen();\n\n    // Konkrete Methode: hat einen Body, wird vererbt\n    public void atmen() {\n        System.out.println(name + " atmet...");\n    }\n}\n\n// new Tier("Test"); // COMPILERFEHLER! Abstrakt = nicht instanziierbar!'
  },
  {
    title: 'Abstrakte Methoden',
    content:
      'Eine abstrakte Methode ist eine Methode OHNE Implementierung (ohne Body). Sie wird mit dem Schluesselwort "abstract" deklariert und endet mit einem Semikolon.\n\nSYNTAX: public abstract Rueckgabetyp methodenName(Parameter);\nBeachte: Keine geschweiften Klammern {}! Nur ein Semikolon!\n\nDie Regel ist einfach:\nJede KONKRETE Unterklasse (also jede nicht-abstrakte Unterklasse) MUSS ALLE abstrakten Methoden der Oberklasse implementieren.\n\nWenn eine Unterklasse NICHT alle abstrakten Methoden implementiert, muss sie SELBST als abstract deklariert werden.\n\nAnalogie: Eine abstrakte Methode ist wie ein Vertrag oder ein Formular. Die Oberklasse sagt: "Wer mich beerbt, MUSS diese Methode ausfuellen!" WIE die Methode ausgefuellt wird, entscheidet jede Unterklasse selbst.',
    code:
      'public abstract class Tier {\n    public abstract void sprechen(); // Kein Body!\n}\n\n// Hund MUSS sprechen() implementieren:\npublic class Hund extends Tier {\n    @Override\n    public void sprechen() { System.out.println("Wuff!"); }\n}\n\n// Katze implementiert es anders:\npublic class Katze extends Tier {\n    @Override\n    public void sprechen() { System.out.println("Miau!"); }\n}\n\n// Polymorphie funktioniert wunderbar:\nTier t1 = new Hund();\nTier t2 = new Katze();\nt1.sprechen(); // "Wuff!"\nt2.sprechen(); // "Miau!"'
  },
  {
    title: 'Finale Klassen und Methoden',
    content:
      'Das Schluesselwort "final" bedeutet: "Hier ist Schluss, keine Aenderungen mehr!"\n\nfinal class: Kann NICHT erweitert (beerbt) werden. Keine Klasse kann "extends FinalClass" schreiben. Beispiel aus Java: String ist eine finale Klasse! Man kann String nicht beerben. Grund: Sicherheit und Unveraenderlichkeit garantieren.\n\nfinal method: Kann in Unterklassen NICHT ueberschrieben werden. Die Implementierung der Oberklasse ist die endgueltige Version. Nuetzlich, wenn eine Methode in allen Unterklassen gleich bleiben soll.\n\nWICHTIG fuer die Pruefung:\nabstract + final = WIDERSPRUCH! Kompiliert NICHT!\n- abstract sagt: "Muss erweitert/ueberschrieben werden"\n- final sagt: "Darf nicht erweitert/ueberschrieben werden"\n- Diese beiden Aussagen widersprechen sich!',
    code:
      '// Finale Klasse -- kann nicht beerbt werden:\npublic final class Konstanten {\n    public static final double PI = 3.14159;\n}\n// class MeineKonstanten extends Konstanten {} // COMPILERFEHLER!\n\n// Finale Methode -- kann nicht ueberschrieben werden:\npublic class Basis {\n    public final void wichtig() {\n        System.out.println("Darf NICHT geaendert werden!");\n    }\n    public void normal() {\n        System.out.println("Kann ueberschrieben werden");\n    }\n}\n\npublic class Kind extends Basis {\n    // @Override public void wichtig() {} // COMPILERFEHLER! final!\n    @Override\n    public void normal() { System.out.println("Neue Version"); }\n}'
  },
  {
    title: 'Interface',
    content:
      'Ein Interface ist ein reiner VERTRAG: Es definiert WAS eine Klasse tun muss, aber NICHT WIE sie es tut.\n\nStell dir ein Interface vor wie eine Stellenbeschreibung: "Wer diesen Job machen will, muss DIESE Faehigkeiten mitbringen." Wie der Bewerber die Faehigkeiten erworben hat, ist egal.\n\nRegeln fuer Interfaces:\n- Alle Methoden sind implizit public abstract (vor Java 8)\n- Seit Java 8: default-Methoden (mit Implementierung) moeglich\n- Seit Java 9: private Hilfsmethoden moeglich\n- KEINE Instanz-Attribute! Nur public static final Konstanten\n- KEIN Konstruktor! Interfaces koennen nicht instanziiert werden\n\nDer grosse Unterschied zur abstrakten Klasse: Eine Klasse kann nur EINE Klasse erweitern (extends), aber MEHRERE Interfaces implementieren (implements)!',
    code:
      '// Interface definieren:\npublic interface Fahrbar {\n    // Implizit public abstract:\n    void fahren();\n    void bremsen();\n\n    // Default-Methode (seit Java 8) -- hat Body:\n    default void hupen() {\n        System.out.println("Huup!");\n    }\n\n    // Konstante (implizit public static final):\n    int MAX_SPEED = 200;\n}\n\npublic interface Parkbar {\n    void einparken();\n    void ausparken();\n}'
  },
  {
    title: 'Interface implementieren',
    content:
      'Eine Klasse implementiert ein Interface mit dem Schluesselwort "implements". Sie MUSS dann ALLE abstrakten Methoden des Interfaces implementieren.\n\nDer grosse Vorteil: Eine Klasse kann MEHRERE Interfaces implementieren!\nSyntax: class X implements InterfaceA, InterfaceB, InterfaceC { ... }\n\nDabei muss die Klasse alle abstrakten Methoden aus ALLEN Interfaces implementieren. Default-Methoden muessen nicht ueberschrieben werden (koennen aber).\n\nEine Klasse kann auch gleichzeitig erben UND Interfaces implementieren:\nclass Auto extends Fahrzeug implements Fahrbar, Parkbar { ... }\nWICHTIG: extends kommt IMMER vor implements!\n\nPolymorphie funktioniert auch mit Interfaces:\nFahrbar f = new Auto(); -- statischer Typ = Interface, dynamischer Typ = Klasse.',
    code:
      '// Klasse implementiert MEHRERE Interfaces:\npublic class Auto extends Fahrzeug implements Fahrbar, Parkbar {\n    @Override\n    public void fahren() { System.out.println("Auto faehrt los"); }\n    @Override\n    public void bremsen() { System.out.println("Auto bremst"); }\n    @Override\n    public void einparken() { System.out.println("Auto parkt ein"); }\n    @Override\n    public void ausparken() { System.out.println("Auto parkt aus"); }\n    // hupen() muss NICHT ueberschrieben werden (default)\n}\n\n// Polymorphie mit Interface-Typ:\nFahrbar f = new Auto();\nf.fahren();  // "Auto faehrt los"\nf.hupen();   // "Huup!" (default-Methode)'
  },
  {
    title: 'Interface vs. Abstrakte Klasse',
    content:
      'Wann benutzt man was? Hier der direkte Vergleich:\n\nABSTRAKTE KLASSE:\n- Kann Instanz-Attribute (Felder mit Zustand) haben\n- Hat Konstruktoren\n- Nur EINFACHVERERBUNG (eine Klasse kann nur eine erweitern)\n- Kann abstract + konkrete Methoden mischen\n- Geeignet fuer: gemeinsame Basis MIT geteiltem Zustand/Implementation\n\nINTERFACE:\n- KEINE Instanz-Attribute (nur public static final Konstanten)\n- KEIN Konstruktor\n- MEHRFACHIMPLEMENTIERUNG moeglich (implements A, B, C)\n- Methoden: abstract, default (Java 8+), private (Java 9+)\n- Geeignet fuer: Faehigkeiten/Vertraege, die verschiedene Klassen teilen\n\nFaustregel:\n- "ist-ein" Beziehung + gemeinsamer Zustand -> abstrakte Klasse (Hund IST EIN Tier)\n- "kann" Beziehung / Faehigkeit -> Interface (Hund KANN schwimmen)',
    code:
      '// Abstrakte Klasse: gemeinsame Basis mit Zustand\npublic abstract class Tier {\n    protected String name;  // Instanz-Attribut!\n    public Tier(String name) { this.name = name; } // Konstruktor!\n    public abstract void sprechen();\n    public void atmen() { System.out.println("Atmet..."); }\n}\n\n// Interfaces: Faehigkeiten\npublic interface Schwimmbar { void schwimmen(); }\npublic interface Trainierbar { void lerneKunststueck(String name); }\n\n// Kombination: extends + implements\npublic class Hund extends Tier implements Schwimmbar, Trainierbar {\n    public Hund(String name) { super(name); }\n    @Override public void sprechen() { System.out.println("Wuff!"); }\n    @Override public void schwimmen() { System.out.println(name + " schwimmt!"); }\n    @Override public void lerneKunststueck(String t) { System.out.println(name + " lernt " + t); }\n}'
  },
  {
    title: 'Das Diamond-Problem',
    content:
      'Was passiert, wenn eine Klasse zwei Interfaces implementiert, die BEIDE eine default-Methode mit dem gleichen Namen haben?\n\nDas ist das sogenannte "Diamond-Problem" (benannt nach der Diamant-Form im Diagramm).\n\nJavas Loesung:\n- Bei KLASSEN gibt es das Problem nicht: Java erlaubt nur Einfachvererbung. Man kann nicht "extends A, B" schreiben.\n- Bei INTERFACES mit gleicher default-Methode: Die implementierende Klasse MUSS die Methode selbst ueberschreiben! Sonst gibt es einen Compilerfehler.\n\nInnerhalb der ueberschriebenen Methode kann man gezielt die default-Methode eines bestimmten Interfaces aufrufen: InterfaceName.super.methode()\n\nDas ist ein beliebtes Pruefungsthema! Merke: Wenn zwei Interfaces die gleiche default-Methode haben, MUSS die Klasse die Mehrdeutigkeit aufloesen.',
    code:
      'interface InterfaceA {\n    default void gruss() { System.out.println("Hallo von A"); }\n}\ninterface InterfaceB {\n    default void gruss() { System.out.println("Hallo von B"); }\n}\n\n// OHNE Override: Compilerfehler!\n// class MeineKlasse implements InterfaceA, InterfaceB { }\n\n// MIT Override: Mehrdeutigkeit aufgeloest!\nclass MeineKlasse implements InterfaceA, InterfaceB {\n    @Override\n    public void gruss() {\n        // Option 1: Eigene Implementierung\n        System.out.println("Hallo von MeineKlasse");\n        // Option 2: Gezielt ein Interface aufrufen\n        // InterfaceA.super.gruss();\n        // Option 3: Beide aufrufen\n        // InterfaceA.super.gruss();\n        // InterfaceB.super.gruss();\n    }\n}'
  }
];
