export const theory = [
  {
    title: 'while-Schleife',
    content: 'Die while-Schleife ist die einfachste Schleifenart in Java. Sie wiederholt einen Codeblock, SOLANGE eine Bedingung wahr (true) ist.\n\nStell dir vor, du stehst vor einer Tuer mit einem Schild: "Nur eintreten, wenn Bedingung erfuellt." Bevor du jeden Schritt machst, schaust du auf das Schild. Sobald die Bedingung nicht mehr gilt, hoerst du auf.\n\nSyntax:\nwhile (bedingung) {\n    // Schleifenkoerper\n}\n\nWICHTIG: Die Bedingung wird VOR jedem Durchlauf geprueft. Ist sie von Anfang an false, wird der Koerper NIE ausgefuehrt.\n\nSchritt-fuer-Schritt Ablauf:\n1. Bedingung pruefen\n2. Wenn true: Koerper ausfuehren, zurueck zu 1\n3. Wenn false: Schleife verlassen',
    code: '// Beispiel: Zaehle von 1 bis 5\nint i = 1;\nwhile (i <= 5) {\n    System.out.println("Durchlauf: " + i);\n    i++;  // WICHTIG: Variable veraendern!\n}\n// Iteration 1: i=1, Ausgabe: "Durchlauf: 1", i wird 2\n// Iteration 2: i=2, Ausgabe: "Durchlauf: 2", i wird 3\n// Iteration 3: i=3, Ausgabe: "Durchlauf: 3", i wird 4\n// Iteration 4: i=4, Ausgabe: "Durchlauf: 4", i wird 5\n// Iteration 5: i=5, Ausgabe: "Durchlauf: 5", i wird 6\n// Pruefung: 6 <= 5? NEIN -> Schleife endet\n\n// Bedingung von Anfang an false:\nint x = 10;\nwhile (x < 5) {\n    System.out.println("Das wird NIE ausgefuehrt!");\n}'
  },
  {
    title: 'do-while-Schleife',
    content: 'Die do-while-Schleife ist der while-Schleife aehnlich, aber mit einem ENTSCHEIDENDEN Unterschied: Der Koerper wird MINDESTENS EINMAL ausgefuehrt, selbst wenn die Bedingung von Anfang an false ist!\n\nAnalogie: Du gehst in ein Restaurant und probierst das Essen (= erster Durchlauf). Erst DANACH entscheidest du, ob du nochmal bestellen willst.\n\nSyntax:\ndo {\n    // Schleifenkoerper\n} while (bedingung);  // <-- Semikolon nicht vergessen!\n\nAblauf:\n1. Koerper ausfuehren (immer!)\n2. Bedingung pruefen\n3. Wenn true: zurueck zu 1\n4. Wenn false: Schleife verlassen\n\nTypischer Anwendungsfall: Menues, Benutzereingaben, die mindestens einmal angezeigt werden sollen.',
    code: '// Vergleich: while vs do-while bei false-Bedingung\n\n// while: Koerper wird NIE ausgefuehrt\nint a = 10;\nwhile (a < 5) {\n    System.out.println("while: " + a); // nie!\n}\n\n// do-while: Koerper wird EINMAL ausgefuehrt\nint b = 10;\ndo {\n    System.out.println("do-while: " + b); // einmal!\n} while (b < 5);\n// Ausgabe: "do-while: 10"\n\n// Praxisbeispiel: Menue\nint wahl;\ndo {\n    System.out.println("1) Spielen  2) Beenden");\n    wahl = scanner.nextInt();\n} while (wahl != 2);'
  },
  {
    title: 'for-Schleife',
    content: 'Die for-Schleife ist perfekt, wenn du VORHER weisst, wie oft die Schleife laufen soll. Sie buendelt Initialisierung, Bedingung und Aktualisierung in einer Zeile.\n\nSyntax:\nfor (initialisierung; bedingung; aktualisierung) {\n    // Schleifenkoerper\n}\n\nAusfuehrungsreihenfolge:\n1. Initialisierung (nur EINMAL am Anfang!)\n2. Bedingung pruefen\n3. Wenn true: Koerper ausfuehren\n4. Aktualisierung ausfuehren\n5. Zurueck zu Schritt 2\n\nBeispiel for(int i=0; i<5; i++):\n- Start: i=0\n- Pruefe 0<5? Ja -> Koerper -> i++ -> i=1\n- Pruefe 1<5? Ja -> Koerper -> i++ -> i=2\n- Pruefe 2<5? Ja -> Koerper -> i++ -> i=3\n- Pruefe 3<5? Ja -> Koerper -> i++ -> i=4\n- Pruefe 4<5? Ja -> Koerper -> i++ -> i=5\n- Pruefe 5<5? NEIN -> Ende\n- Ergebnis: 5 Durchlaeufe mit i = 0, 1, 2, 3, 4',
    code: '// Vorwaerts zaehlen (0 bis 4)\nfor (int i = 0; i < 5; i++) {\n    System.out.println(i); // 0, 1, 2, 3, 4\n}\n\n// Rueckwaerts zaehlen (5 bis 1)\nfor (int i = 5; i >= 1; i--) {\n    System.out.println(i); // 5, 4, 3, 2, 1\n}\n\n// Zweierschritte\nfor (int i = 0; i <= 10; i += 2) {\n    System.out.println(i); // 0, 2, 4, 6, 8, 10\n}\n\n// WICHTIG: Die Variable i existiert NUR\n// innerhalb der for-Schleife!\n// System.out.println(i); // Compilerfehler!'
  },
  {
    title: 'Enhanced for (for-each)',
    content: 'Die for-each-Schleife (auch "Enhanced for" genannt) ist eine vereinfachte Schleife zum Durchlaufen von Arrays und Collections. Du brauchst keinen Index und kannst direkt mit den Elementen arbeiten.\n\nSyntax:\nfor (Typ element : sammlung) {\n    // element nutzen\n}\n\nLies es als: "Fuer jedes Element in Sammlung, tue..."\n\nVorteile:\n- Kuerzer und uebersichtlicher\n- Keine IndexOutOfBoundsException moeglich\n- Perfekt, wenn du jeden Wert einmal brauchst\n\nEinschraenkungen:\n- Kein Zugriff auf den Index\n- Array kann waehrend der Iteration nicht veraendert werden\n- Kein Rueckwaerts-Durchlauf moeglich',
    code: '// Array mit for-each durchlaufen\nString[] namen = {"Anna", "Ben", "Clara"};\nfor (String name : namen) {\n    System.out.println("Hallo " + name);\n}\n// Ausgabe:\n// Hallo Anna\n// Hallo Ben\n// Hallo Clara\n\n// Summe berechnen\nint[] zahlen = {10, 20, 30, 40};\nint summe = 0;\nfor (int z : zahlen) {\n    summe += z;\n}\nSystem.out.println("Summe: " + summe); // 100\n\n// Vergleich: for vs for-each\nfor (int i = 0; i < namen.length; i++) {\n    System.out.println(namen[i]); // Index noetig\n}\nfor (String n : namen) {\n    System.out.println(n);  // direkt das Element\n}'
  },
  {
    title: 'break und continue',
    content: 'break und continue sind Steueranweisungen, die den normalen Schleifenablauf veraendern.\n\nbreak: VerlÃ¤sst die Schleife SOFORT. Kein weiterer Code im Koerper wird ausgefuehrt, keine weitere Pruefung der Bedingung. Die Ausfuehrung geht nach der Schleife weiter.\n\ncontinue: Ueberspringt den REST des aktuellen Durchlaufs und springt direkt zur naechsten Iteration (bei for: erst Aktualisierung, dann Bedingung).\n\nAnalogie:\n- break = "Ich gehe jetzt nach Hause!" (komplett raus)\n- continue = "Diesen Schritt ueberspringe ich, aber ich mache weiter." (nur dieser Durchlauf wird abgebrochen)',
    code: '// break: Schleife bei 5 abbrechen\nfor (int i = 0; i < 10; i++) {\n    if (i == 5) break;\n    System.out.print(i + " ");\n}\n// Ausgabe: 0 1 2 3 4\n// (5 wird NICHT mehr ausgegeben)\n\n// continue: Ungerade Zahlen ueberspringen\nfor (int i = 0; i < 8; i++) {\n    if (i % 2 != 0) continue;\n    System.out.print(i + " ");\n}\n// Ausgabe: 0 2 4 6\n// (1, 3, 5, 7 werden uebersprungen)\n\n// Kombination: Suche erstes Element\nint[] daten = {3, 7, 2, 9, 4};\nfor (int d : daten) {\n    if (d == 2) {\n        System.out.println("Gefunden!");\n        break; // sofort aufhoeren\n    }\n}'
  },
  {
    title: 'Verschachtelte Schleifen',
    content: 'Verschachtelte Schleifen sind Schleifen innerhalb von Schleifen. Die innere Schleife laeuft bei JEDEM Durchlauf der aeusseren Schleife KOMPLETT durch.\n\nAnalogie: Stell dir ein Gebaeude mit Stockwerken (aeussere Schleife) und Zimmern pro Stockwerk (innere Schleife) vor. Fuer jedes Stockwerk besuchst du ALLE Zimmer.\n\nBei einer aeusseren Schleife mit n Durchlaeufen und einer inneren mit m Durchlaeufen ergibt das n * m Gesamtdurchlaeufe.\n\nBeispiel: aeussere 3x, innere 4x = 12 Durchlaeufe gesamt.\n\nWICHTIG: Verwende verschiedene Variablennamen (i, j, k) fuer die Zaehler!',
    code: '// Multiplikationstabelle (1x1 bis 3x3)\nfor (int i = 1; i <= 3; i++) {\n    for (int j = 1; j <= 3; j++) {\n        System.out.print(i * j + "\\t");\n    }\n    System.out.println();\n}\n// Ausgabe:\n// 1  2  3\n// 2  4  6\n// 3  6  9\n\n// Rechteck aus Sternen (3 Zeilen, 5 Spalten)\nfor (int zeile = 0; zeile < 3; zeile++) {\n    for (int spalte = 0; spalte < 5; spalte++) {\n        System.out.print("*");\n    }\n    System.out.println();\n}\n// Ausgabe:\n// *****\n// *****\n// *****'
  },
  {
    title: 'Endlosschleifen',
    content: 'Eine Endlosschleife ist eine Schleife, die niemals von selbst endet, weil ihre Bedingung immer true bleibt.\n\nBewusste Endlosschleifen:\n- while(true) { ... } - die gaengigste Form\n- for(;;) { ... } - Kurzform (alle drei Teile leer)\n- Werden mit break gezielt beendet\n- Nuetzlich fuer Spiel-Schleifen, Server, Menues\n\nUnbeabsichtigte Endlosschleifen (BUGS!):\n- Vergessen, den Zaehler zu erhoehen\n- Bedingung kann nie false werden\n- Variable wird in die falsche Richtung veraendert\n\nWie vermeiden?\n- Immer pruefen: Wird die Variable im Koerper veraendert?\n- Wird die Bedingung irgendwann false?\n- Im Zweifel: Sicherheits-Zaehler einbauen',
    code: '// Bewusste Endlosschleife mit break\nwhile (true) {\n    System.out.println("Menue:");\n    int wahl = scanner.nextInt();\n    if (wahl == 0) {\n        break; // Schleife verlassen\n    }\n}\n\n// Kurzform mit for\nfor (;;) {\n    // laeuft endlos bis break\n    break;\n}\n\n// FEHLER: Vergessenes i++\nint i = 0;\nwhile (i < 5) {\n    System.out.println(i);\n    // i++ vergessen! -> Endlosschleife!\n    // i bleibt immer 0, 0 < 5 ist immer true\n}\n\n// FEHLER: Falsche Richtung\nfor (int x = 0; x < 10; x--) {\n    // x wird kleiner statt groesser!\n    // x < 10 ist immer true -> Endlosschleife\n}'
  }
];
