export const theory = [
  {
    title: 'Was ist eine ArrayList?',
    content: 'Stell dir vor, du hast ein Regal mit genau 5 Fächern (ein Array). Was passiert, wenn du ein 6. Buch hinstellen willst? Du brauchst ein neues, größeres Regal!\n\nGenau dieses Problem löst die ArrayList. Sie ist wie ein magisches Regal, das automatisch wächst, wenn du mehr Platz brauchst.\n\nEine ArrayList ist eine dynamische Liste aus dem Paket java.util.\nIm Gegensatz zu einem Array:\n- Hat sie KEINE feste Größe - sie wächst und schrumpft automatisch\n- Speichert NUR Objekte (keine primitiven Typen wie int oder double)\n- Wird über Methoden bedient (nicht über [] Klammern)\n\nDie Syntax zum Erstellen:\nArrayList<Typ> name = new ArrayList<>();\n\nDas <Typ> ist ein sogenannter Generic - es legt fest, welche Art von Objekten die Liste speichern darf. Das ist wie ein Etikett auf dem Regal: "Nur Bücher" oder "Nur DVDs".\n\nWICHTIG: Du musst java.util.ArrayList importieren!\nimport java.util.ArrayList;',
    code: 'import java.util.ArrayList;\n\n// ArrayList für Strings erstellen\nArrayList<String> namen = new ArrayList<>();\n\n// ArrayList für Integer (nicht int!)\nArrayList<Integer> zahlen = new ArrayList<>();\n\n// ArrayList für eigene Objekte\nArrayList<Student> studenten = new ArrayList<>();\n\n// FEHLER: Primitive Typen gehen NICHT!\n// ArrayList<int> liste;    // COMPILERFEHLER!\n// ArrayList<double> liste; // COMPILERFEHLER!'
  },
  {
    title: 'Wichtige Methoden - Hinzufügen und Zugreifen',
    content: 'Die ArrayList hat viele nützliche Methoden. Hier die wichtigsten zum Hinzufügen und Lesen:\n\nadd(element) - Fügt ein Element am ENDE der Liste hinzu.\nDie Liste wächst automatisch um 1.\n\nadd(index, element) - Fügt ein Element an einer bestimmten Position ein.\nAlle nachfolgenden Elemente rutschen um eine Position nach rechts.\nDer Index muss zwischen 0 und size() liegen!\n\nget(index) - Gibt das Element an der Position zurück.\nACHTUNG: Wenn der Index ungültig ist (negativ oder >= size()),\ngibt es eine IndexOutOfBoundsException!\n\nsize() - Gibt die Anzahl der Elemente zurück.\nNICHT verwechseln mit .length bei Arrays! Bei ArrayList ist es .size().',
    code: 'ArrayList<String> fruechte = new ArrayList<>();\n\n// add(element) - am Ende anfügen\nfruechte.add("Apfel");    // [Apfel]\nfruechte.add("Banane");   // [Apfel, Banane]\nfruechte.add("Kirsche");  // [Apfel, Banane, Kirsche]\n\n// add(index, element) - an Position einfügen\nfruechte.add(1, "Orange"); // [Apfel, Orange, Banane, Kirsche]\n// Orange wird an Index 1 eingefügt, Rest rutscht nach rechts\n\n// get(index) - Element lesen\nString erstes = fruechte.get(0);  // "Apfel"\nString zweites = fruechte.get(1); // "Orange"\n\n// size() - Anzahl der Elemente\nSystem.out.println(fruechte.size()); // 4\n\n// FEHLER: Ungültiger Index\n// fruechte.get(10); // IndexOutOfBoundsException!'
  },
  {
    title: 'Wichtige Methoden - Ändern, Entfernen, Suchen',
    content: 'set(index, element) - Ersetzt das Element an der Position.\nGibt das alte Element zurück.\n\nremove(index) - Entfernt das Element an der Position.\nAlle nachfolgenden Elemente rutschen um 1 nach links.\nGibt das entfernte Element zurück.\n\nremove(Object) - Entfernt das ERSTE Vorkommen des Objekts.\nGibt true zurück, wenn es gefunden und entfernt wurde.\n\ncontains(element) - Prüft, ob das Element in der Liste ist.\nGibt true oder false zurück.\n\nisEmpty() - Prüft, ob die Liste leer ist (size() == 0).\n\nindexOf(element) - Gibt den Index des ersten Vorkommens zurück.\nGibt -1 zurück, wenn das Element nicht gefunden wurde.\n\nclear() - Entfernt ALLE Elemente. Die Liste ist danach leer.',
    code: 'ArrayList<String> tiere = new ArrayList<>();\ntiere.add("Hund"); tiere.add("Katze"); tiere.add("Vogel");\n// [Hund, Katze, Vogel]\n\n// set - Element ersetzen\ntiere.set(1, "Fisch");  // [Hund, Fisch, Vogel]\n\n// remove(index) - nach Position entfernen\ntiere.remove(0);        // [Fisch, Vogel] (Hund entfernt)\n\n// remove(Object) - nach Wert entfernen\ntiere.add("Fisch");     // [Fisch, Vogel, Fisch]\ntiere.remove("Fisch");  // [Vogel, Fisch] (nur erstes!)\n\n// contains - Enthält die Liste...?\nSystem.out.println(tiere.contains("Vogel")); // true\nSystem.out.println(tiere.contains("Hund"));  // false\n\n// indexOf - Position finden\nSystem.out.println(tiere.indexOf("Vogel"));  // 0\nSystem.out.println(tiere.indexOf("Hund"));   // -1\n\n// isEmpty und clear\nSystem.out.println(tiere.isEmpty()); // false\ntiere.clear();                       // []\nSystem.out.println(tiere.isEmpty()); // true'
  },
  {
    title: 'ArrayList vs. Array - Der Vergleich',
    content: 'Wann benutzt man was? Hier ein direkter Vergleich:\n\n          Array                    ArrayList\nGröße:    fest (bei Erstellung)    dynamisch (wächst/schrumpft)\nTypen:    Primitiv + Objekte       NUR Objekte\nSyntax:   int[] arr = new int[5]   ArrayList<Integer> list = new ArrayList<>()\nZugriff:  arr[i]                   list.get(i)\nÄndern:   arr[i] = wert            list.set(i, wert)\nLänge:    arr.length (Feld!)       list.size() (Methode!)\nHinzuf.:  NICHT MÖGLICH            list.add(element)\nEntfern.: NICHT MÖGLICH            list.remove(index)\n\nFaustregel:\n- Array: Wenn die Größe feststeht und sich nie ändert (z.B. Wochentage)\n- ArrayList: Wenn Elemente hinzugefügt oder entfernt werden müssen\n\nWICHTIG: Array hat .length (OHNE Klammern, ein Feld!)\nArrayList hat .size() (MIT Klammern, eine Methode!)\nDas ist eine beliebte Klausur-Falle!',
    code: '// Array - feste Größe\nint[] noten = new int[3];\nnoten[0] = 1;\nnoten[1] = 2;\n// noten hat IMMER 3 Plätze, auch wenn nur 2 belegt\n\n// ArrayList - dynamische Größe\nArrayList<Integer> notenListe = new ArrayList<>();\nnotenListe.add(1);\nnotenListe.add(2);\n// notenListe hat genau 2 Elemente, wächst bei Bedarf\n\n// Länge abfragen:\nSystem.out.println(noten.length);      // 3 (OHNE Klammern!)\nSystem.out.println(notenListe.size()); // 2 (MIT Klammern!)\n\n// Array zu ArrayList konvertieren:\nString[] arr = {"A", "B", "C"};\nArrayList<String> list = new ArrayList<>(Arrays.asList(arr));'
  },
  {
    title: 'Autoboxing, Unboxing und die remove()-Falle',
    content: 'Da ArrayList keine primitiven Typen speichern kann, brauchen wir Wrapper-Klassen:\nint → Integer, double → Double, boolean → Boolean usw.\n\nAutoboxing: Java wandelt primitiv → Wrapper AUTOMATISCH um.\nDu kannst also einfach list.add(5) schreiben, obwohl die Liste Integer speichert.\nJava macht daraus automatisch list.add(Integer.valueOf(5)).\n\nUnboxing: Java wandelt Wrapper → primitiv AUTOMATISCH um.\nint x = list.get(0) funktioniert, obwohl get() ein Integer zurückgibt.\n\nABER ACHTUNG - Die remove()-Falle (KLAUSUR-KLASSIKER!):\nBei ArrayList<Integer> hat remove() zwei Bedeutungen:\n- remove(int index): Entfernt an der POSITION\n- remove(Object obj): Entfernt den WERT\n\nWenn du remove(1) schreibst, wird das Element an INDEX 1 entfernt!\nUm den WERT 1 zu entfernen, musst du remove(Integer.valueOf(1)) schreiben.\nDas ist eine der häufigsten Klausur-Fallen!',
    code: '// Autoboxing: int wird automatisch zu Integer\nArrayList<Integer> zahlen = new ArrayList<>();\nzahlen.add(10);  // Autoboxing: 10 → Integer.valueOf(10)\nzahlen.add(20);\nzahlen.add(30);\n// Liste: [10, 20, 30]\n\n// Unboxing: Integer wird automatisch zu int\nint wert = zahlen.get(0);  // Unboxing: Integer → int\n\n// DIE FALLE: remove() bei Integer-Listen!\nzahlen.remove(1);  // Entfernt an INDEX 1 → 20 wird entfernt!\n// Liste: [10, 30]\n\n// Um den WERT 1 zu entfernen:\nArrayList<Integer> liste = new ArrayList<>();\nliste.add(1); liste.add(2); liste.add(3);\n// Liste: [1, 2, 3]\n\nliste.remove(1);                // Entfernt INDEX 1 → [1, 3]\nliste.remove(Integer.valueOf(1)); // Entfernt WERT 1 → [3]'
  },
  {
    title: 'Iteration über eine ArrayList',
    content: 'Es gibt mehrere Wege, über eine ArrayList zu iterieren:\n\n1. Klassische for-Schleife mit Index:\n   for (int i = 0; i < list.size(); i++)\n   Vorteil: Du hast den Index und kannst Elemente ändern/entfernen.\n\n2. Enhanced for-each-Schleife:\n   for (Typ element : list)\n   Vorteil: Kürzer und lesbarer.\n   NACHTEIL: Du darfst die Liste NICHT verändern während der Iteration!\n   Sonst gibt es eine ConcurrentModificationException!\n\n3. Beim Entfernen während der Iteration:\n   Benutze die klassische for-Schleife und zähle rückwärts (i--)!\n   Oder: Benutze einen Iterator mit iterator.remove().\n   NIEMALS for-each für Entfernen verwenden!\n\nTypischer Fehler in Klausuren: for-each benutzen und gleichzeitig\nmit remove() Elemente entfernen. Das stürzt IMMER ab!',
    code: '// 1. Klassische for-Schleife\nArrayList<String> namen = new ArrayList<>();\nnamen.add("Anna"); namen.add("Ben"); namen.add("Clara");\n\nfor (int i = 0; i < namen.size(); i++) {\n    System.out.println(namen.get(i));\n}\n\n// 2. Enhanced for-each\nfor (String name : namen) {\n    System.out.println(name);\n}\n\n// 3. Sicheres Entfernen: Rückwärts iterieren!\nfor (int i = namen.size() - 1; i >= 0; i--) {\n    if (namen.get(i).startsWith("B")) {\n        namen.remove(i);  // Sicher!\n    }\n}\n\n// FEHLER: Entfernen mit for-each\n// for (String n : namen) {\n//     if (n.startsWith("A")) namen.remove(n);\n//     // ConcurrentModificationException!\n// }'
  },
  {
    title: 'List.of() und Arrays.asList()',
    content: 'Java bietet verschiedene Wege, Listen schnell zu erstellen:\n\n1. List.of(elemente...) - Erstellt eine UNVERÄNDERLICHE Liste.\n   Man kann NICHTS hinzufügen, entfernen oder ändern!\n   Bei jedem Versuch gibt es eine UnsupportedOperationException.\n   Gut für Konstanten, z.B. List.of("Mo", "Di", "Mi", "Do", "Fr").\n\n2. Arrays.asList(array) - Erstellt eine Liste fester Größe.\n   Man kann Elemente ÄNDERN (set), aber NICHT hinzufügen oder entfernen.\n   Die Liste ist mit dem Array verbunden: Änderungen wirken sich aus!\n\n3. new ArrayList<>(List.of(...)) - Erstellt eine VERÄNDERLICHE Kopie.\n   Das ist der Trick: Wickle eine unveränderliche Liste in eine neue ArrayList.\n   Jetzt kannst du add, remove, set - alles benutzen!\n\nFür Klausuren merken:\n- List.of() → komplett unveränderlich\n- Arrays.asList() → Größe fest, Inhalt änderbar\n- new ArrayList<>(Collection) → voll veränderlich',
    code: 'import java.util.List;\nimport java.util.Arrays;\n\n// 1. List.of() - UNVERÄNDERLICH!\nList<String> tage = List.of("Mo", "Di", "Mi");\nSystem.out.println(tage.get(0)); // "Mo"\n// tage.add("Do");    // UnsupportedOperationException!\n// tage.remove(0);    // UnsupportedOperationException!\n// tage.set(0, "XX"); // UnsupportedOperationException!\n\n// 2. Arrays.asList() - Feste Größe, aber änderbar\nList<String> farben = Arrays.asList("Rot", "Grün", "Blau");\nfarben.set(0, "Gelb");   // OK! [Gelb, Grün, Blau]\n// farben.add("Pink");   // UnsupportedOperationException!\n\n// 3. Veränderliche Kopie erstellen\nArrayList<String> flex = new ArrayList<>(List.of("A", "B"));\nflex.add("C");     // OK! [A, B, C]\nflex.remove(0);    // OK! [B, C]\nflex.set(0, "X");  // OK! [X, C]'
  },
  {
    title: 'ArrayList als Attribut (Klausur-Muster!)',
    content: 'Eines der WICHTIGSTEN Klausur-Muster: Eine Klasse hat eine ArrayList als Attribut.\nDas kommt in fast jeder Klausur vor! Das Muster sieht immer gleich aus:\n\n1. Die Klasse hat ein privates ArrayList-Attribut\n2. Der Konstruktor erstellt eine NEUE, LEERE ArrayList\n3. Es gibt Methoden zum Hinzufügen, Entfernen, Suchen und Filtern\n\nBeispiel: Ein Zoo verwaltet eine Liste von Tieren.\nJedes Tier hat einen Namen und eine Art.\nDer Zoo hat Methoden, um Tiere hinzuzufügen, zu suchen und aufzulisten.\n\nDieses Muster musst du im Schlaf beherrschen!\nTypische Methoden:\n- void addTier(Tier t) - Tier hinzufügen\n- Tier findByName(String name) - Tier nach Name suchen (null wenn nicht gefunden)\n- ArrayList<Tier> filterByArt(String art) - Alle Tiere einer Art\n- void removeByName(String name) - Tier nach Name entfernen',
    code: 'public class Zoo {\n    private ArrayList<Tier> tiere;\n\n    public Zoo() {\n        this.tiere = new ArrayList<>(); // Leere Liste!\n    }\n\n    public void addTier(Tier t) {\n        tiere.add(t);\n    }\n\n    public Tier findByName(String name) {\n        for (Tier t : tiere) {\n            if (t.getName().equals(name)) {\n                return t;\n            }\n        }\n        return null; // Nicht gefunden\n    }\n\n    public ArrayList<Tier> filterByArt(String art) {\n        ArrayList<Tier> ergebnis = new ArrayList<>();\n        for (Tier t : tiere) {\n            if (t.getArt().equals(art)) {\n                ergebnis.add(t);\n            }\n        }\n        return ergebnis;\n    }\n\n    public void removeByName(String name) {\n        for (int i = tiere.size() - 1; i >= 0; i--) {\n            if (tiere.get(i).getName().equals(name)) {\n                tiere.remove(i);\n            }\n        }\n    }\n}'
  },
  {
    title: 'Verschachtelte ArrayList',
    content: 'Eine ArrayList kann auch andere ArrayLists enthalten!\nArrayList<ArrayList<String>> ist eine Liste von Listen.\nDas ist wie eine 2D-Struktur, aber dynamisch.\n\nStell dir eine Schule vor:\n- Die Schule hat mehrere Klassen (äußere Liste)\n- Jede Klasse hat mehrere Schüler (innere Liste)\n\nZugriff auf ein Element:\naußen.get(i) → gibt die innere ArrayList zurück\naußen.get(i).get(j) → gibt das Element in der inneren Liste zurück\n\nDas ist wie Koordinaten: Erst die Zeile (i), dann die Spalte (j).\n\nDu kannst auch dynamisch innere Listen erstellen und hinzufügen.\nDas kommt seltener in Klausuren vor, aber wenn es vorkommt,\nmüssen die Studenten genau wissen, wie der Zugriff funktioniert.\n\nTipp: Zuerst die innere Liste erstellen und befüllen,\ndann erst zur äußeren Liste hinzufügen.',
    code: '// Verschachtelte ArrayList: Liste von Listen\nArrayList<ArrayList<String>> schule = new ArrayList<>();\n\n// Klasse 1 erstellen und befüllen\nArrayList<String> klasse1 = new ArrayList<>();\nklasse1.add("Anna");\nklasse1.add("Ben");\n\n// Klasse 2 erstellen und befüllen\nArrayList<String> klasse2 = new ArrayList<>();\nklasse2.add("Clara");\nklasse2.add("David");\nklasse2.add("Eva");\n\n// Klassen zur Schule hinzufügen\nschule.add(klasse1);\nschule.add(klasse2);\n\n// Zugriff: schule.get(Klasse).get(Schüler)\nSystem.out.println(schule.get(0).get(1)); // "Ben"\nSystem.out.println(schule.get(1).get(0)); // "Clara"\n\n// Alle Schüler aller Klassen ausgeben:\nfor (int i = 0; i < schule.size(); i++) {\n    System.out.println("Klasse " + (i + 1) + ":");\n    for (int j = 0; j < schule.get(i).size(); j++) {\n        System.out.println("  " + schule.get(i).get(j));\n    }\n}'
  }
];
