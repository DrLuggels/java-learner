export const theory = [
  {
    title: 'Warum brauchen wir Sortierung?',
    content: 'Stell dir vor, du hast eine Liste von Studenten und willst sie sortieren.\nFür Zahlen und Strings weiß Java automatisch, wie sortiert wird:\n- Zahlen: 1, 2, 3, 4 (aufsteigend)\n- Strings: "Anna", "Ben", "Clara" (alphabetisch)\n\nAber was ist mit EIGENEN Klassen? Wenn du eine Klasse Student hast,\nwoher soll Java wissen, ob nach Name, Note oder Alter sortiert werden soll?\n\nCollections.sort() braucht eine VERGLEICHSREGEL!\n\nJava bietet zwei Wege, diese Regel zu definieren:\n\n1. Comparable (vergleichbar) - Die Klasse SELBST definiert ihre Sortierung\n   → "Ich weiß selbst, wie ich mich mit anderen vergleiche"\n   → Wird IN der Klasse implementiert\n   → Definiert die NATÜRLICHE Ordnung (natural order)\n\n2. Comparator (Vergleicher) - Eine SEPARATE Klasse definiert die Sortierung\n   → "Jemand anderes sagt mir, wie ich sortiert werde"\n   → Wird AUSSERHALB der Klasse erstellt\n   → Erlaubt MEHRERE verschiedene Sortierungen\n\nBeide benutzen das gleiche Prinzip: Zwei Objekte vergleichen\nund sagen, welches "kleiner" (= weiter vorn) ist.',
    code: 'import java.util.ArrayList;\nimport java.util.Collections;\n\n// Für Standard-Typen funktioniert sort() sofort:\nArrayList<Integer> zahlen = new ArrayList<>();\nzahlen.add(3); zahlen.add(1); zahlen.add(2);\nCollections.sort(zahlen);\n// [1, 2, 3] → Java weiß, wie man Zahlen sortiert\n\nArrayList<String> namen = new ArrayList<>();\nnamen.add("Clara"); namen.add("Anna"); namen.add("Ben");\nCollections.sort(namen);\n// [Anna, Ben, Clara] → alphabetisch\n\n// Aber für eigene Klassen?\nArrayList<Student> studenten = new ArrayList<>();\n// Collections.sort(studenten); // FEHLER!\n// → Java weiß nicht, wie man Studenten vergleicht!'
  },
  {
    title: 'Das Comparable<T> Interface',
    content: 'Wenn eine Klasse das Interface Comparable<T> implementiert, sagt sie:\n"Ich weiß selbst, wie ich mich mit anderen Objekten meines Typs vergleiche!"\n\nDu musst genau EINE Methode implementieren:\n  int compareTo(T other)\n\nDiese Methode vergleicht THIS (das aktuelle Objekt) mit OTHER (das andere).\n\nRückgabewerte:\n- Negativ (z.B. -1): this kommt VOR other (this < other)\n- Null (0):           this und other sind GLEICH\n- Positiv (z.B. +1):  this kommt NACH other (this > other)\n\nMerksatz für aufsteigende Sortierung:\n"this MINUS other" → Ergebnis bestimmt die Reihenfolge\n\nWenn du nach einer Zahl sortierst (z.B. Alter):\n- this.alter - other.alter → aufsteigend (klein nach groß)\n- BESSER: Integer.compare(this.alter, other.alter) → kein Überlauf!\n\nWenn du nach einem String sortierst (z.B. Name):\n- this.name.compareTo(other.name) → alphabetisch aufsteigend\n\nDas ist die NATÜRLICHE ORDNUNG der Klasse. Jede Klasse hat nur EINE.',
    code: '// Student implementiert Comparable → sortierbar!\npublic class Student implements Comparable<Student> {\n    private String name;\n    private int alter;\n\n    public Student(String name, int alter) {\n        this.name = name;\n        this.alter = alter;\n    }\n\n    // Natürliche Ordnung: nach Alter aufsteigend\n    @Override\n    public int compareTo(Student other) {\n        return Integer.compare(this.alter, other.alter);\n    }\n\n    // Getter...\n    public String getName() { return name; }\n    public int getAlter() { return alter; }\n}\n\n// Jetzt funktioniert Collections.sort()!\nArrayList<Student> liste = new ArrayList<>();\nliste.add(new Student("Clara", 25));\nliste.add(new Student("Anna", 20));\nliste.add(new Student("Ben", 22));\nCollections.sort(liste);\n// Reihenfolge: Anna(20), Ben(22), Clara(25)'
  },
  {
    title: 'compareTo() Rückgabewerte im Detail',
    content: 'Schauen wir uns ganz genau an, was bei compareTo() passiert:\n\nBeispiel: Anna (20 Jahre) wird mit Ben (25 Jahre) verglichen.\nAnna.compareTo(Ben)\n→ Integer.compare(20, 25)\n→ Ergebnis: NEGATIV (20 < 25)\n→ Bedeutung: Anna kommt VOR Ben ✓ (aufsteigend nach Alter)\n\nBeispiel: Ben (25 Jahre) wird mit Anna (20 Jahre) verglichen.\nBen.compareTo(Anna)\n→ Integer.compare(25, 20)\n→ Ergebnis: POSITIV (25 > 20)\n→ Bedeutung: Ben kommt NACH Anna ✓\n\nBeispiel: Anna (20 Jahre) wird mit Clara (20 Jahre) verglichen.\nAnna.compareTo(Clara)\n→ Integer.compare(20, 20)\n→ Ergebnis: 0 (gleich)\n→ Bedeutung: Gleiche Position in der Sortierung\n\nWICHTIG: Benutze Integer.compare() statt Subtraktion!\nthis.alter - other.alter KANN bei extremen Werten einen\nInteger-Überlauf verursachen! Integer.compare() ist SICHER.\n\nFür Strings: String hat bereits compareTo() eingebaut!\nthis.name.compareTo(other.name) vergleicht alphabetisch.',
    code: '// Verschiedene Vergleiche demonstriert:\nStudent anna = new Student("Anna", 20);\nStudent ben = new Student("Ben", 25);\nStudent clara = new Student("Clara", 20);\n\nSystem.out.println(anna.compareTo(ben));\n// Negativ → Anna kommt vor Ben (20 < 25)\n\nSystem.out.println(ben.compareTo(anna));\n// Positiv → Ben kommt nach Anna (25 > 20)\n\nSystem.out.println(anna.compareTo(clara));\n// 0 → Gleiche Sortierposition (20 == 20)\n\n// Vergleich nach Name statt Alter:\npublic int compareTo(Student other) {\n    return this.name.compareTo(other.name);\n    // String.compareTo vergleicht alphabetisch\n    // "Anna".compareTo("Ben") → negativ (A vor B)\n}\n\n// ABSTEIGEND sortieren? Einfach umdrehen!\npublic int compareTo(Student other) {\n    return Integer.compare(other.alter, this.alter);\n    // other und this vertauscht → absteigend!\n}'
  },
  {
    title: 'Das Comparator<T> Interface',
    content: 'Was, wenn du MEHRERE Sortierungen brauchst? Z.B. einmal nach Alter,\neinmal nach Name, einmal nach Note? Comparable erlaubt nur EINE!\n\nDie Lösung: Comparator<T> - eine SEPARATE Vergleichsklasse.\n\nEin Comparator ist eine eigene Klasse, die das Interface Comparator<T>\nimplementiert. Sie hat genau EINE Methode:\n  int compare(T a, T b)\n\nDer Unterschied zu compareTo():\n- compareTo(other): Vergleicht THIS mit other (ist IN der Klasse)\n- compare(a, b): Vergleicht ZWEI fremde Objekte (ist AUSSERHALB)\n\nDie Rückgabewerte sind identisch:\n- Negativ: a kommt vor b\n- Null: a und b sind gleich\n- Positiv: a kommt nach b\n\nVorteil: Du kannst BELIEBIG VIELE Comparatoren schreiben!\n- NameComparator: sortiert nach Name\n- AlterComparator: sortiert nach Alter\n- NoteComparator: sortiert nach Note\n\nDie Original-Klasse muss dafür NICHT geändert werden!',
    code: 'import java.util.Comparator;\n\n// Comparator als eigene Klasse:\npublic class NameComparator implements Comparator<Student> {\n    @Override\n    public int compare(Student a, Student b) {\n        return a.getName().compareTo(b.getName());\n    }\n}\n\npublic class AlterComparator implements Comparator<Student> {\n    @Override\n    public int compare(Student a, Student b) {\n        return Integer.compare(a.getAlter(), b.getAlter());\n    }\n}\n\n// Verwendung: Verschiedene Sortierungen!\nArrayList<Student> liste = new ArrayList<>();\nliste.add(new Student("Clara", 20));\nliste.add(new Student("Anna", 25));\nliste.add(new Student("Ben", 22));\n\n// Nach Name sortieren:\nCollections.sort(liste, new NameComparator());\n// [Anna(25), Ben(22), Clara(20)]\n\n// Nach Alter sortieren:\nCollections.sort(liste, new AlterComparator());\n// [Clara(20), Ben(22), Anna(25)]'
  },
  {
    title: 'Collections.sort() - Zwei Varianten',
    content: 'Collections.sort() gibt es in zwei Versionen:\n\n1. Collections.sort(list)\n   → Benutzt die NATÜRLICHE Ordnung (Comparable)\n   → Die Klasse MUSS Comparable implementieren!\n   → Wenn nicht → ClassCastException zur Laufzeit!\n\n2. Collections.sort(list, comparator)\n   → Benutzt den übergebenen Comparator\n   → Die Klasse muss NICHT Comparable implementieren\n   → Der Comparator bestimmt die Sortierreihenfolge\n\nWICHTIG: Wenn du Version 1 benutzt und die Klasse Comparable\nNICHT implementiert, gibt es KEINEN Compilerfehler!\nDer Fehler kommt erst zur LAUFZEIT als ClassCastException.\nDas ist eine fiese Klausur-Falle!\n\nFür Standard-Typen (Integer, String, Double) ist Comparable\nbereits implementiert, daher funktioniert sort(list) immer.\n\nTipp: Du kannst auch list.sort(comparator) verwenden.\nDas ist eine Methode direkt auf der Liste (seit Java 8).',
    code: '// Version 1: Natürliche Ordnung (Comparable)\n// Student implementiert Comparable<Student> nach Alter\nArrayList<Student> liste = new ArrayList<>();\nliste.add(new Student("Clara", 25));\nliste.add(new Student("Anna", 20));\n\nCollections.sort(liste);\n// Benutzt Student.compareTo() → nach Alter\n// [Anna(20), Clara(25)]\n\n// Version 2: Mit Comparator\nCollections.sort(liste, new NameComparator());\n// Ignoriert compareTo(), benutzt NameComparator.compare()\n// [Anna(20), Clara(25)] (hier zufällig gleich)\n\n// Alternative Syntax (seit Java 8):\nliste.sort(new AlterComparator());\n\n// FEHLER: Klasse ohne Comparable + sort() ohne Comparator\n// class Hund { String name; } // kein Comparable!\n// ArrayList<Hund> hunde = new ArrayList<>();\n// Collections.sort(hunde); // ClassCastException!'
  },
  {
    title: 'Absteigende Sortierung',
    content: 'Standardmäßig sortiert Java AUFSTEIGEND (klein → groß, A → Z).\nFür absteigende Sortierung gibt es mehrere Wege:\n\n1. Vergleich umdrehen (im Comparator):\n   Statt compare(a, b) schreibe compare(b, a).\n   Du tauschst einfach a und b!\n\n2. Ergebnis negieren:\n   return -Integer.compare(a.getAlter(), b.getAlter());\n   Das Minuszeichen dreht die Richtung um.\n\n3. .reversed() auf einem Comparator:\n   Comparator<Student> absteigend = new AlterComparator().reversed();\n   Das nimmt einen bestehenden Comparator und dreht ihn um.\n\n4. Comparator.reverseOrder() für natürliche Ordnung:\n   Collections.sort(zahlen, Comparator.reverseOrder());\n   Dreht die natürliche Ordnung (Comparable) um.\n\nFür Klausuren empfehle ich Methode 1 oder 2, weil sie am\nklarsten zeigen, dass du das Prinzip verstanden hast.',
    code: '// Methode 1: a und b vertauschen\npublic class AlterAbsteigendComparator\n        implements Comparator<Student> {\n    @Override\n    public int compare(Student a, Student b) {\n        return Integer.compare(b.getAlter(), a.getAlter());\n        // b vor a → absteigend!\n    }\n}\n\n// Methode 2: Ergebnis negieren\npublic int compare(Student a, Student b) {\n    return -Integer.compare(a.getAlter(), b.getAlter());\n}\n\n// Methode 3: .reversed()\nComparator<Student> aufsteigend = new AlterComparator();\nComparator<Student> absteigend = aufsteigend.reversed();\nCollections.sort(liste, absteigend);\n\n// Methode 4: reverseOrder() für Standardtypen\nArrayList<Integer> zahlen = new ArrayList<>(List.of(3, 1, 2));\nCollections.sort(zahlen, Comparator.reverseOrder());\n// [3, 2, 1]\n\nArrayList<String> woerter = new ArrayList<>(List.of("C", "A", "B"));\nCollections.sort(woerter, Comparator.reverseOrder());\n// [C, B, A]'
  },
  {
    title: 'Multi-Level-Sortierung (mehrstufig)',
    content: 'Was, wenn zwei Studenten das gleiche Alter haben?\nDann brauchst du ein ZWEITES Sortierkriterium!\n\nBeispiel: Sortiere Studenten zuerst nach Note, dann nach Name.\nWenn zwei die gleiche Note haben, entscheidet der Name.\n\nDas Muster ist immer gleich:\n1. Vergleiche nach dem ersten Kriterium\n2. Wenn das Ergebnis NICHT 0 ist → fertig, gib es zurück\n3. Wenn das Ergebnis 0 ist (gleich) → vergleiche nach dem zweiten Kriterium\n\nIn Code:\nint result = Integer.compare(a.getNote(), b.getNote());\nif (result != 0) return result;     // Noten unterschiedlich\nreturn a.getName().compareTo(b.getName()); // Noten gleich → Name\n\nDas kannst du beliebig tief verschachteln:\nErst Note, dann Name, dann Alter, dann...\n\nJede Stufe wird nur verglichen, wenn alle vorherigen gleich waren.\nDas ist wie bei einer Rangliste: Erst Punkte, dann bei Gleichstand\ndie Tordifferenz, dann die Anzahl Tore, dann das Los.',
    code: '// Multi-Level: Erst nach Note, dann nach Name\npublic class StudentSortierer\n        implements Comparator<Student> {\n    @Override\n    public int compare(Student a, Student b) {\n        // Stufe 1: Nach Note (aufsteigend)\n        int result = Integer.compare(\n            a.getNote(), b.getNote()\n        );\n        // Wenn Noten unterschiedlich → fertig\n        if (result != 0) {\n            return result;\n        }\n        // Stufe 2: Noten gleich → nach Name\n        return a.getName().compareTo(b.getName());\n    }\n}\n\n// Beispiel:\n// Anna(2.0), Ben(1.3), Clara(2.0), David(1.3)\n// Sortiert:\n// Ben(1.3), David(1.3), Anna(2.0), Clara(2.0)\n// Ben vor David (gleiche Note, B vor D)\n// Anna vor Clara (gleiche Note, A vor C)\n\n// Drei Stufen: Note → Name → Alter\nint result = Integer.compare(a.getNote(), b.getNote());\nif (result != 0) return result;\nresult = a.getName().compareTo(b.getName());\nif (result != 0) return result;\nreturn Integer.compare(a.getAlter(), b.getAlter());'
  },
  {
    title: 'Comparable + Comparator Combo (Klausur!)',
    content: 'In Klausuren kommt oft folgendes Muster:\n- Eine Klasse implementiert Comparable für die natürliche Ordnung\n- Zusätzlich gibt es einen oder mehrere Comparatoren für alternative Ordnungen\n\nBeispiel: Produkt hat Name und Preis.\n- Natürliche Ordnung (Comparable): nach Name alphabetisch\n- Alternativer Comparator: nach Preis aufsteigend\n- Weiterer Comparator: nach Preis absteigend\n\nSo kannst du dasselbe Produkt-Array auf drei verschiedene Arten sortieren, ohne die Produkt-Klasse jedes Mal zu ändern.\n\nCollections.sort(liste) → benutzt compareTo() → nach Name\nCollections.sort(liste, new PreisComparator()) → nach Preis\nCollections.sort(liste, new PreisComparator().reversed()) → Preis absteigend\n\nDas ist das vollständige Klausur-Muster. Lerne es auswendig!\nDie Klasse implementiert Comparable, und für jede\nalternative Sortierung gibt es einen eigenen Comparator.',
    code: '// Produkt mit Comparable (natürliche Ordnung: Name)\npublic class Produkt implements Comparable<Produkt> {\n    private String name;\n    private double preis;\n\n    public Produkt(String name, double preis) {\n        this.name = name;\n        this.preis = preis;\n    }\n\n    @Override\n    public int compareTo(Produkt other) {\n        return this.name.compareTo(other.name); // nach Name\n    }\n\n    public String getName() { return name; }\n    public double getPreis() { return preis; }\n}\n\n// Separater Comparator für Preis\npublic class PreisComparator implements Comparator<Produkt> {\n    @Override\n    public int compare(Produkt a, Produkt b) {\n        return Double.compare(a.getPreis(), b.getPreis());\n    }\n}\n\n// Verwendung: Drei Sortierungen!\nArrayList<Produkt> shop = new ArrayList<>();\nshop.add(new Produkt("Banane", 1.20));\nshop.add(new Produkt("Apfel", 2.50));\nshop.add(new Produkt("Cherry", 0.80));\n\nCollections.sort(shop);\n// [Apfel, Banane, Cherry] → Comparable (Name)\n\nCollections.sort(shop, new PreisComparator());\n// [Cherry(0.80), Banane(1.20), Apfel(2.50)] → Preis auf\n\nCollections.sort(shop, new PreisComparator().reversed());\n// [Apfel(2.50), Banane(1.20), Cherry(0.80)] → Preis ab'
  }
];
