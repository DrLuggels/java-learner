export const theory = [
  {
    title: 'Was ist eine Exception?',
    content: 'Stell dir vor, du fährst Auto und plötzlich platzt ein Reifen. Du hattest das nicht geplant, aber es passiert. Was tust du? Du hältst an, wechselst den Reifen und fährst weiter. Genau das ist Exception Handling!\n\nEine Exception (Ausnahme) ist ein Fehler, der WÄHREND der Laufzeit auftritt.\nDas bedeutet: Der Code kompiliert fehlerfrei, aber beim Ausführen geht etwas schief.\n\nBeispiele für Laufzeitfehler:\n- Division durch Null: 10 / 0\n- Zugriff auf null: String s = null; s.length();\n- Ungültiger Array-Index: int[] arr = {1,2}; arr[5];\n- Datei nicht gefunden: new FileReader("gibtsNicht.txt");\n\nOhne Exception Handling stürzt dein Programm sofort ab!\nMit Exception Handling kannst du den Fehler abfangen, eine sinnvolle Fehlermeldung ausgeben und das Programm weiterlaufen lassen.\n\nDie wichtigste Regel: Exceptions sind für UNERWARTETE Situationen.\nSie sind NICHT für normale Programmlogik gedacht!',
    code: '// OHNE Exception Handling - Programm stürzt ab!\nint[] zahlen = {1, 2, 3};\nSystem.out.println(zahlen[10]); // ArrayIndexOutOfBoundsException!\n// Alles nach dieser Zeile wird NICHT mehr ausgeführt!\n\n// MIT Exception Handling - Programm läuft weiter\ntry {\n    System.out.println(zahlen[10]);\n} catch (ArrayIndexOutOfBoundsException e) {\n    System.out.println("Ungültiger Index!");\n}\nSystem.out.println("Programm läuft weiter!"); // Wird ausgeführt!'
  },
  {
    title: 'Die Exception-Hierarchie',
    content: 'Alle Fehler in Java haben eine Vererbungshierarchie:\n\n                    Throwable\n                   /         \\\n               Error          Exception\n              /                /        \\\n     OutOfMemoryError   RuntimeException  IOException\n     StackOverflowError /       |     \\     FileNotFoundException\n                       /        |      \\\n      NullPointer-  ArrayIndex-  IllegalArgument-\n      Exception     OutOfBounds  Exception\n                    Exception\n\nThrowable: Die Oberklasse von ALLEM, was geworfen werden kann.\n\nError: Schwerwiegende Systemfehler. Diese sollst du NICHT fangen!\n- OutOfMemoryError: Kein Speicher mehr\n- StackOverflowError: Zu tiefe Rekursion\n\nException: Fehler, die dein Programm behandeln kann und soll.\n- RuntimeException: "Unchecked" Exceptions (Programmierfehler)\n- Andere Exceptions: "Checked" Exceptions (vorhersehbare Probleme)\n\nDiese Hierarchie ist entscheidend für das Verständnis von\nchecked vs. unchecked Exceptions!',
    code: '// Verschiedene Ebenen der Hierarchie:\n\n// Error - NICHT fangen! (Systemfehler)\n// OutOfMemoryError, StackOverflowError\n\n// RuntimeException (unchecked) - Programmierfehler\nString s = null;\n// s.length();  // NullPointerException\n\nint[] arr = {1};\n// arr[5];      // ArrayIndexOutOfBoundsException\n\n// int x = 10 / 0; // ArithmeticException\n\n// Checked Exception - Vorhersehbare Probleme\n// new FileReader("x.txt"); // FileNotFoundException\n// → Compiler ZWINGT dich, diese zu behandeln!'
  },
  {
    title: 'Checked vs. Unchecked Exceptions',
    content: 'Das ist eine der WICHTIGSTEN Unterscheidungen in Java!\n\nCHECKED Exceptions (geprüfte Ausnahmen):\n- Der Compiler ZWINGT dich, sie zu behandeln!\n- Du MUSST entweder try-catch verwenden ODER throws deklarieren\n- Sind Unterklassen von Exception (aber NICHT von RuntimeException)\n- Beispiele: IOException, FileNotFoundException, SQLException\n- Wann: Für Probleme, die du vorhersehen kannst\n  (Datei existiert nicht, Netzwerk nicht verfügbar)\n\nUNCHECKED Exceptions (ungeprüfte Ausnahmen):\n- Der Compiler zwingt dich NICHT, sie zu behandeln\n- Sind Unterklassen von RuntimeException\n- Beispiele: NullPointerException, ArrayIndexOutOfBoundsException,\n  IllegalArgumentException, NumberFormatException\n- Wann: Programmierfehler, die durch besseren Code vermieden werden können\n\nMerksatz:\n- Checked = "Kann passieren, sei vorbereitet!" (Datei fehlt)\n- Unchecked = "Hättest du besser programmiert!" (null-Zugriff)',
    code: '// CHECKED: Compiler zwingt zur Behandlung\nimport java.io.FileReader;\n\n// Das kompiliert NICHT ohne try-catch oder throws:\n// FileReader fr = new FileReader("datei.txt"); // FEHLER!\n\n// Lösung 1: try-catch\ntry {\n    FileReader fr = new FileReader("datei.txt");\n} catch (FileNotFoundException e) {\n    System.out.println("Datei nicht gefunden!");\n}\n\n// Lösung 2: throws (siehe späteres Kapitel)\n// void lesen() throws FileNotFoundException { ... }\n\n// UNCHECKED: Compiler sagt nichts, Fehler erst zur Laufzeit\nString text = null;\n// text.length(); // NullPointerException (unchecked)\n\nint zahl = Integer.parseInt("abc"); // NumberFormatException'
  },
  {
    title: 'try-catch-finally',
    content: 'Das ist das Herzstück der Fehlerbehandlung:\n\ntry { ... } - Hier steht der "riskante" Code, der fehlschlagen könnte.\n\ncatch (ExceptionTyp e) { ... } - Hier fängst du den Fehler ab.\nDer Parameter e enthält Informationen über den Fehler:\n- e.getMessage() → Die Fehlermeldung als String\n- e.printStackTrace() → Gibt den kompletten Fehlerverlauf aus\n\nfinally { ... } - Wird IMMER ausgeführt, egal ob Fehler oder nicht!\nSogar wenn im try oder catch ein return steht!\nVerwendung: Ressourcen aufräumen (Dateien schließen, Verbindungen trennen).\n\nMehrere catch-Blöcke: Du kannst verschiedene Fehlertypen unterschiedlich behandeln. WICHTIG: Spezifischste Exception ZUERST!\nWenn du Exception vor NumberFormatException schreibst, ist der zweite catch unerreichbar (Compilerfehler).\n\nMulti-catch: catch(IOException | SQLException e) fängt mehrere Typen in einem Block.',
    code: '// Grundstruktur\ntry {\n    int ergebnis = 10 / 0;\n} catch (ArithmeticException e) {\n    System.out.println("Fehler: " + e.getMessage());\n    // Ausgabe: "Fehler: / by zero"\n} finally {\n    System.out.println("Wird IMMER ausgeführt!");\n}\n\n// Mehrere catch-Blöcke (spezifisch → allgemein!)\ntry {\n    String s = null;\n    s.length();\n} catch (NullPointerException e) {\n    System.out.println("Null-Zugriff!");\n} catch (RuntimeException e) {\n    System.out.println("Laufzeitfehler!");\n} catch (Exception e) {\n    System.out.println("Irgendein Fehler!");\n}\n// NullPointerException ist spezifischer als RuntimeException!\n\n// finally mit return: finally gewinnt!\ntry {\n    return 1;   // return wird vorbereitet...\n} finally {\n    System.out.println("Trotzdem!"); // ...aber das läuft noch!\n}'
  },
  {
    title: 'throw - Exceptions aktiv werfen',
    content: 'Mit dem Schlüsselwort throw kannst du selbst eine Exception auslösen.\nDas ist wie ein Feueralarm, den du manuell auslöst.\n\nSyntax: throw new ExceptionTyp("Fehlermeldung");\n\nWichtig:\n- throw (ohne s) WIRFT eine Exception\n- Nach throw wird der Rest der Methode NICHT mehr ausgeführt!\n- Die Exception wandert den Call-Stack hoch, bis sie gefangen wird\n- Wenn sie NIRGENDS gefangen wird, stürzt das Programm ab\n\nTypischer Einsatz: Eingabevalidierung!\nWenn eine Methode ungültige Parameter bekommt, wirft sie eine Exception.\n\nWelche Exception für welchen Fall?\n- IllegalArgumentException: Ungültiger Parameter\n- IllegalStateException: Objekt ist in falschem Zustand\n- NullPointerException: null wo es nicht sein darf\n\nNach throw bricht die aktuelle Methode sofort ab.\nDie Exception fliegt nach oben durch den Call-Stack.',
    code: '// Eingabevalidierung mit throw\npublic void setAlter(int alter) {\n    if (alter < 0) {\n        throw new IllegalArgumentException(\n            "Alter darf nicht negativ sein: " + alter\n        );\n    }\n    if (alter > 150) {\n        throw new IllegalArgumentException(\n            "Alter unrealistisch hoch: " + alter\n        );\n    }\n    this.alter = alter;\n}\n\n// Aufrufer muss damit umgehen:\ntry {\n    person.setAlter(-5);\n} catch (IllegalArgumentException e) {\n    System.out.println(e.getMessage());\n    // "Alter darf nicht negativ sein: -5"\n}\n\n// Call-Stack: Exception wandert nach oben\n// main() → methodA() → methodB() → throw!\n// Exception fliegt: methodB → methodA → main\n// Erster catch auf dem Weg fängt sie ab!'
  },
  {
    title: 'throws - Exceptions deklarieren',
    content: 'throws (MIT s am Ende) steht in der Methoden-Signatur und sagt:\n"Diese Methode KÖNNTE diese Exception werfen!"\n\nSyntax: void methode() throws ExceptionTyp { ... }\n\nWarum braucht man das?\nBei CHECKED Exceptions hast du zwei Möglichkeiten:\n1. try-catch in der Methode selbst → du behandelst den Fehler\n2. throws in der Signatur → du gibst die Verantwortung weiter!\n\nBei throws muss der AUFRUFER die Exception behandeln:\n- Entweder mit try-catch\n- Oder er schreibt selbst throws (Verantwortung weiter nach oben)\n\nDie Exception wandert die Aufrufkette hoch:\nmain() → leseDatei() → öffneDatei() → throws IOException\nWenn öffneDatei() IOException wirft und leseDatei() sie nicht fängt,\nmuss leseeDatei() auch throws IOException deklarieren.\nUnd wenn main() sie nicht fängt, stürzt das Programm ab.\n\nFür UNCHECKED Exceptions (RuntimeException) brauchst du throws NICHT,\nkannst es aber zur Dokumentation hinschreiben.',
    code: '// throws: Verantwortung an den Aufrufer weitergeben\nimport java.io.FileReader;\nimport java.io.IOException;\n\n// Diese Methode KÖNNTE eine IOException werfen\npublic void lesen() throws IOException {\n    FileReader fr = new FileReader("datei.txt");\n    // Wenn Datei nicht existiert: IOException\n    // Wir fangen sie NICHT, der Aufrufer muss es tun!\n}\n\n// Aufrufer MUSS jetzt handeln:\n// Option 1: try-catch\npublic void verarbeiten() {\n    try {\n        lesen();\n    } catch (IOException e) {\n        System.out.println("Fehler beim Lesen!");\n    }\n}\n\n// Option 2: throws weitergeben\npublic void verarbeiten2() throws IOException {\n    lesen(); // Verantwortung geht weiter nach oben!\n}\n\n// Mehrere Exceptions deklarieren:\npublic void methode() throws IOException, SQLException {\n    // Kann beide Exceptions werfen\n}'
  },
  {
    title: 'Eigene Exception erstellen',
    content: 'Du kannst eigene Exception-Klassen schreiben! Das ist besonders nützlich, wenn du spezifische Fehlerfälle in deiner Anwendung beschreiben willst.\n\nFür eine CHECKED Exception: extends Exception\nFür eine UNCHECKED Exception: extends RuntimeException\n\nMindestanforderung:\n- Eine Klasse, die von Exception oder RuntimeException erbt\n- Ein Konstruktor, der eine Fehlermeldung an super() weitergibt\n\nDas super(message) im Konstruktor ist WICHTIG!\nDamit wird die Fehlermeldung an die Elternklasse Exception übergeben.\nDadurch funktioniert e.getMessage() später beim catch.\n\nWann eigene Exceptions?\n- Wenn keine Standard-Exception den Fehler gut beschreibt\n- Wenn du zusätzliche Daten zum Fehler speichern willst\n- Wenn der Aufrufer zwischen verschiedenen Fehlerarten unterscheiden soll\n\nKonvention: Der Klassenname endet IMMER auf "Exception"!\nGut: KontoLeerException, ZuJungException\nSchlecht: KontoLeerFehler, ZuJungProblem',
    code: '// Eigene CHECKED Exception\npublic class ZuJungException extends Exception {\n    public ZuJungException(String message) {\n        super(message); // Fehlermeldung an Exception übergeben\n    }\n}\n\n// Eigene UNCHECKED Exception\npublic class UngueltigerNameException extends RuntimeException {\n    public UngueltigerNameException(String message) {\n        super(message);\n    }\n}\n\n// Verwendung:\npublic void registrieren(String name, int alter)\n        throws ZuJungException {  // Checked → throws nötig!\n    if (name == null || name.isEmpty()) {\n        // Unchecked → kein throws nötig\n        throw new UngueltigerNameException("Name ist leer!");\n    }\n    if (alter < 18) {\n        // Checked → throws in Signatur!\n        throw new ZuJungException(\n            "Mindestalter 18, aber: " + alter\n        );\n    }\n}\n\n// Aufrufer:\ntry {\n    registrieren("Max", 16);\n} catch (ZuJungException e) {\n    System.out.println(e.getMessage());\n    // "Mindestalter 18, aber: 16"\n}'
  },
  {
    title: 'Exception mit zusätzlichen Daten (Klausur!)',
    content: 'In Klausuren wird oft verlangt: Erstelle eine Exception-Klasse,\ndie ZUSÄTZLICHE DATEN zum Fehler speichert.\n\nDas Muster ist immer gleich:\n1. Klasse erbt von Exception (oder RuntimeException)\n2. Private Felder für die zusätzlichen Daten\n3. Konstruktor: nimmt message + zusätzliche Daten\n   - super(message) für die Fehlermeldung\n   - this.feld = feld für die zusätzlichen Daten\n4. Getter für die zusätzlichen Daten\n\nBeispiel: TooLowBudgetException\nWenn jemand nicht genug Geld hat, wollen wir wissen:\n- Was ist die Fehlermeldung? (über getMessage())\n- Wie viel Budget hatte die Person? (über getBudget())\n- Wie viel hätte sie gebraucht? (über getRequired())\n\nBeim Fangen der Exception kann der Aufrufer dann auf die\nzusätzlichen Daten zugreifen, um eine hilfreiche Fehlermeldung\nzu erstellen oder eine passende Reaktion auszulösen.',
    code: '// Exception mit zusätzlichen Daten\npublic class TooLowBudgetException extends Exception {\n    private double budget;    // vorhandenes Budget\n    private double required;  // benötigter Betrag\n\n    public TooLowBudgetException(String message,\n            double budget, double required) {\n        super(message);            // Fehlermeldung\n        this.budget = budget;      // Zusatzdaten\n        this.required = required;\n    }\n\n    public double getBudget() { return budget; }\n    public double getRequired() { return required; }\n}\n\n// Verwendung in einer Methode:\npublic void kaufen(String produkt, double preis)\n        throws TooLowBudgetException {\n    if (this.kontostand < preis) {\n        throw new TooLowBudgetException(\n            "Nicht genug Geld für " + produkt,\n            this.kontostand,  // vorhandenes Budget\n            preis             // benötigter Betrag\n        );\n    }\n    this.kontostand -= preis;\n}\n\n// Aufrufer greift auf Zusatzdaten zu:\ntry {\n    kunde.kaufen("Laptop", 999.99);\n} catch (TooLowBudgetException e) {\n    System.out.println(e.getMessage());\n    System.out.println("Vorhanden: " + e.getBudget());\n    System.out.println("Benötigt: " + e.getRequired());\n    double differenz = e.getRequired() - e.getBudget();\n    System.out.println("Es fehlen: " + differenz + " Euro");\n}'
  }
];
