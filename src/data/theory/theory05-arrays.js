export const theory = [
  {
    title: 'Was ist ein Array?',
    content: 'Ein Array ist ein Container fester Groesse, der mehrere Werte des GLEICHEN Typs speichert. Stell dir ein Array wie eine Reihe nummerierter Schubladen vor: Jede Schublade hat eine Nummer (Index) und enthaelt genau einen Wert.\n\nWichtige Eigenschaften:\n- Feste Groesse: Die Laenge wird bei der Erstellung festgelegt und kann NICHT mehr geaendert werden!\n- Gleicher Typ: Alle Elemente muessen vom selben Datentyp sein (z.B. nur int oder nur String)\n- Zusammenhaengender Speicher: Die Elemente liegen hintereinander im Speicher, was schnellen Zugriff ermoeglicht\n- Nullbasierte Indizierung: Das erste Element hat Index 0, nicht 1!\n\nWarum Arrays?\n- Statt 100 einzelne Variablen zu deklarieren, nutzt du EIN Array mit 100 Plaetzen\n- Perfekt, wenn du eine bekannte, feste Anzahl von Werten speichern willst'
  },
  {
    title: 'Array-Deklaration und Initialisierung',
    content: 'Es gibt zwei Wege, ein Array zu erstellen:\n\n1. Mit new (Groesse angeben, Standardwerte):\nint[] zahlen = new int[5];\nErstellt ein Array mit 5 Plaetzen. Alle Plaetze werden automatisch mit Standardwerten gefuellt:\n- int, double, etc.: 0 bzw. 0.0\n- boolean: false\n- Objekte (String, etc.): null\n\n2. Direkte Initialisierung (Werte angeben):\nint[] zahlen = {10, 20, 30};\nErstellt ein Array mit genau 3 Plaetzen und fuellt sie sofort.\n\nWICHTIG: Bei der direkten Initialisierung bestimmt die Anzahl der Werte die Groesse. Du kannst sie NICHT nachtraeglich aendern!\n\nBeide Schreibweisen sind gueltig:\nint[] a = ...;  // bevorzugt in Java\nint a[] = ...;  // C-Stil, funktioniert auch',
    code: '// Variante 1: Mit new (Standardwerte)\nint[] noten = new int[4];       // [0, 0, 0, 0]\nboolean[] flags = new boolean[3]; // [false, false, false]\nString[] namen = new String[2];   // [null, null]\n\n// Variante 2: Direkte Initialisierung\nint[] primzahlen = {2, 3, 5, 7, 11};\nString[] farben = {"Rot", "Gruen", "Blau"};\n\n// Werte nachtraeglich setzen\nnoten[0] = 1;  // erstes Element\nnoten[1] = 3;  // zweites Element\nnoten[2] = 2;\nnoten[3] = 1;\n// noten ist jetzt: [1, 3, 2, 1]'
  },
  {
    title: 'Zugriff und length',
    content: 'Array-Elemente werden ueber ihren Index angesprochen. ACHTUNG: Der Index beginnt bei 0!\n\nBei einem Array mit 5 Elementen:\n- Erstes Element: array[0]\n- Letztes Element: array[4] oder allgemein: array[array.length - 1]\n- Gueltige Indizes: 0, 1, 2, 3, 4\n\narray.length gibt die Laenge des Arrays zurueck. WICHTIG: length ist ein FELD (ohne Klammern!). Das ist anders als bei Strings:\n- Array:  array.length   (Feld, OHNE Klammern)\n- String: string.length() (Methode, MIT Klammern)\nDas ist eine beliebte Klausurfalle!\n\nFehler bei ungueltigem Index:\nWenn du auf einen Index zugreifst, der nicht existiert (kleiner 0 oder groesser/gleich length), wirft Java eine ArrayIndexOutOfBoundsException. Das Programm stuerzt dann ab!',
    code: '// Zugriff auf Elemente\nint[] a = {10, 20, 30, 40, 50};\n\nSystem.out.println(a[0]);   // 10 (erstes)\nSystem.out.println(a[4]);   // 50 (letztes)\nSystem.out.println(a[a.length - 1]); // 50 (letztes, allgemein)\n\n// length ist ein Feld (ohne Klammern!)\nSystem.out.println(a.length); // 5\n\n// Vergleich: String benutzt eine Methode!\nString s = "Hallo";\nSystem.out.println(s.length()); // 5 (MIT Klammern!)\n\n// FEHLER: Index ausserhalb des gueltigen Bereichs\n// a[5]  -> ArrayIndexOutOfBoundsException!\n// a[-1] -> ArrayIndexOutOfBoundsException!'
  },
  {
    title: 'Iteration ueber Arrays',
    content: 'Es gibt zwei gaengige Wege, alle Elemente eines Arrays zu durchlaufen:\n\n1. Klassische for-Schleife (mit Index):\nfor (int i = 0; i < array.length; i++)\n- Du hast Zugriff auf den Index i\n- Du kannst Elemente veraendern: array[i] = neuerWert;\n- Du kannst vorwaerts und rueckwaerts laufen\n\n2. For-each-Schleife (ohne Index):\nfor (int element : array)\n- Einfacher und uebersichtlicher\n- Kein Index verfuegbar\n- Kann das Array NICHT veraendern\n- Laeuft immer vorwaerts\n\nWann welche?\n- Brauchst du den Index? -> for-Schleife\n- Willst du Werte aendern? -> for-Schleife\n- Nur lesen? -> for-each (einfacher)',
    code: '// Klassische for-Schleife (mit Index)\nint[] noten = {1, 3, 2, 4, 1};\nfor (int i = 0; i < noten.length; i++) {\n    System.out.println("Note " + (i+1) + ": " + noten[i]);\n}\n// Note 1: 1\n// Note 2: 3\n// Note 3: 2\n// ...\n\n// For-each-Schleife (kein Index)\ndouble summe = 0;\nfor (int note : noten) {\n    summe += note;\n}\nSystem.out.println("Schnitt: " + summe / noten.length);\n\n// Werte aendern: nur mit for moeglich!\nfor (int i = 0; i < noten.length; i++) {\n    noten[i] = noten[i] + 1; // jede Note +1\n}'
  },
  {
    title: 'Mehrdimensionale Arrays',
    content: 'Ein mehrdimensionales Array ist ein Array von Arrays. Am haeufigsten: zweidimensionale Arrays (Matrizen/Tabellen).\n\nStell dir eine Tabelle vor:\n- Zeilen = erste Dimension (aeusseres Array)\n- Spalten = zweite Dimension (inneres Array)\n\nDeklaration: int[][] matrix = new int[zeilen][spalten];\nZugriff: matrix[zeile][spalte]\n\nmatrix.length = Anzahl der Zeilen\nmatrix[0].length = Anzahl der Spalten (der ersten Zeile)\n\nIteration: Verschachtelte Schleifen! Aeussere Schleife fuer Zeilen, innere fuer Spalten.\n\nDirekte Initialisierung:\nint[][] m = { {1,2,3}, {4,5,6} };\n-> 2 Zeilen, 3 Spalten',
    code: '// 2D-Array erstellen (3 Zeilen, 4 Spalten)\nint[][] matrix = new int[3][4];\nmatrix[0][0] = 1;  // Zeile 0, Spalte 0\nmatrix[2][3] = 99;  // Zeile 2, Spalte 3\n\n// Direkte Initialisierung\nint[][] noten = {\n    {1, 2, 3},   // Zeile 0\n    {4, 5, 6},   // Zeile 1\n    {7, 8, 9}    // Zeile 2\n};\nSystem.out.println(noten[1][2]); // 6\n\n// Iteration mit verschachtelten Schleifen\nfor (int i = 0; i < noten.length; i++) {\n    for (int j = 0; j < noten[i].length; j++) {\n        System.out.print(noten[i][j] + " ");\n    }\n    System.out.println();\n}\n// 1 2 3\n// 4 5 6\n// 7 8 9'
  },
  {
    title: 'VarArgs (Variable Argumente)',
    content: 'VarArgs erlauben es, einer Methode eine VARIABLE Anzahl von Argumenten zu uebergeben. Innerhalb der Methode werden sie als Array behandelt.\n\nSyntax: void methode(int... zahlen)\nDie drei Punkte (...) machen den Parameter zum VarArg.\n\nRegeln:\n- Ein VarArg-Parameter muss der LETZTE Parameter sein\n- Es darf nur EIN VarArg-Parameter pro Methode geben\n- Du kannst 0, 1 oder beliebig viele Argumente uebergeben\n- Innerhalb der Methode: zahlen ist ein normales int[]\n\nBeispiel fuer Aufruf:\nmethode()         -> zahlen = []\nmethode(1)        -> zahlen = [1]\nmethode(1, 2, 3)  -> zahlen = [1, 2, 3]',
    code: '// VarArgs-Methode: Summe beliebig vieler Zahlen\npublic static int summe(int... zahlen) {\n    int ergebnis = 0;\n    for (int z : zahlen) {\n        ergebnis += z;\n    }\n    return ergebnis;\n}\n\n// Aufrufe:\nsumme()           // 0 (leeres Array)\nsumme(5)          // 5\nsumme(1, 2, 3, 4) // 10\n\n// VarArgs muss LETZTER Parameter sein:\npublic static void info(String name, int... noten) {\n    System.out.println(name + " hat " + noten.length + " Noten");\n}\ninfo("Max", 1, 2, 3); // "Max hat 3 Noten"\n\n// FEHLER: VarArgs nicht am Ende\n// void falsch(int... a, String b) // Compilerfehler!'
  },
  {
    title: 'String[] args in der main-Methode',
    content: 'Die main-Methode hat den Parameter String[] args. Dieses Array enthaelt die Kommandozeilenargumente, die beim Programmstart uebergeben werden.\n\nBeispiel Aufruf: java MeinProgramm Hallo Welt 42\n- args[0] = "Hallo"\n- args[1] = "Welt"\n- args[2] = "42"  (als String, nicht als int!)\n- args.length = 3\n\nWICHTIG: Anders als in C/C++ ist args[0] NICHT der Programmname, sondern das erste echte Argument!\n\nWenn keine Argumente uebergeben werden, ist args ein leeres Array (args.length == 0), NICHT null.',
    code: '// Kommandozeilenargumente nutzen\npublic class Begruessung {\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.out.println("Kein Name angegeben!");\n        } else {\n            System.out.println("Hallo " + args[0] + "!");\n        }\n    }\n}\n// Aufruf: java Begruessung Max\n// Ausgabe: Hallo Max!\n\n// Argumente sind immer Strings!\n// Zum Rechnen muessen sie konvertiert werden:\nif (args.length >= 1) {\n    int zahl = Integer.parseInt(args[0]);\n    System.out.println(zahl * 2);\n}\n// Aufruf: java Programm 21\n// Ausgabe: 42'
  },
  {
    title: 'Arrays.toString()',
    content: 'Wenn du ein Array direkt mit System.out.println() ausgibst, erhaeltst du NICHT die Inhalte, sondern eine kryptische Speicheradresse wie [I@1b6d3586.\n\nDas liegt daran, dass Arrays die toString()-Methode nicht sinnvoll ueberschreiben.\n\nLoesung: Verwende Arrays.toString(array) aus dem Paket java.util.Arrays. Diese Methode gibt eine lesbare Darstellung zurueck: [element1, element2, element3]\n\nFuer 2D-Arrays: Arrays.deepToString(matrix)\n\nWICHTIG: Du musst java.util.Arrays importieren!\nimport java.util.Arrays;\n\nDas ist eine haeufige Fehlerquelle bei Anfaengern. Merke: Arrays IMMER mit Arrays.toString() ausgeben!',
    code: '// OHNE Arrays.toString() -> unlesbarer Output\nint[] zahlen = {1, 2, 3};\nSystem.out.println(zahlen);\n// Ausgabe: [I@1b6d3586  (Speicheradresse!)\n\n// MIT Arrays.toString() -> lesbarer Output\nimport java.util.Arrays;\n\nSystem.out.println(Arrays.toString(zahlen));\n// Ausgabe: [1, 2, 3]\n\nString[] namen = {"Anna", "Ben"};\nSystem.out.println(Arrays.toString(namen));\n// Ausgabe: [Anna, Ben]\n\n// Fuer 2D-Arrays: deepToString()\nint[][] matrix = {{1, 2}, {3, 4}};\nSystem.out.println(Arrays.toString(matrix));\n// Ausgabe: [[I@..., [I@...]  (falsch!)\nSystem.out.println(Arrays.deepToString(matrix));\n// Ausgabe: [[1, 2], [3, 4]]  (richtig!)'
  }
];
