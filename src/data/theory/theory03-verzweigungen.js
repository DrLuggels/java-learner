export const theory = [
  {
    title: 'Die if-Anweisung',
    content: 'Die if-Anweisung ist die einfachste Form der Verzweigung. Sie führt einen Codeblock NUR aus, wenn eine Bedingung true ergibt.\n\nSyntax:\n   if (bedingung) {\n       // Code, der nur bei true ausgeführt wird\n   }\n\nWichtige Regeln:\n• Die Bedingung MUSS ein boolean-Ausdruck sein (true oder false)\n• Die Bedingung steht IMMER in runden Klammern ()\n• Der Codeblock steht in geschweiften Klammern {}\n\nOhne geschweifte Klammern wird nur die NÄCHSTE EINE Zeile als if-Block behandelt:\n   if (x > 0)\n       System.out.println("positiv");  // Gehört zum if\n   System.out.println("immer");        // Wird IMMER ausgeführt!\n\nDas ist eine häufige Fehlerquelle! Darum die Regel:\nVerwende IMMER geschweifte Klammern, auch bei nur einer Zeile!\n\nTypische Bedingungen:\n• Vergleiche: x > 5, alter >= 18, name.equals("Anna")\n• boolean-Variablen: if (istAktiv)\n• Methodenaufrufe: if (liste.isEmpty())',
    code: '// Einfache if-Anweisung\nint alter = 20;\nif (alter >= 18) {\n    System.out.println("Du bist volljährig!");\n}\n\n// Mit boolean-Variable\nboolean istAngemeldet = true;\nif (istAngemeldet) {\n    System.out.println("Willkommen!");\n}\n\n// GEFAHR ohne Klammern:\nint x = 5;\nif (x > 10)\n    System.out.println("Groß");      // Nur diese Zeile gehört zum if\nSystem.out.println("Diese Zeile wird IMMER ausgeführt!");\n// → Ausgabe: "Diese Zeile wird IMMER ausgeführt!"'
  },
  {
    title: 'if-else – Zwei Wege',
    content: 'Mit if-else definierst du zwei Wege: Einen für true und einen für false.\nEs wird IMMER genau EINER der beiden Blöcke ausgeführt – niemals beide, niemals keiner.\n\nSyntax:\n   if (bedingung) {\n       // Wird ausgeführt wenn true\n   } else {\n       // Wird ausgeführt wenn false\n   }\n\nStell dir eine Weggabelung vor:\n• Bedingung true → geh nach links (if-Block)\n• Bedingung false → geh nach rechts (else-Block)\n\nBeispiel aus dem Alltag:\n• Wenn es regnet → nimm einen Schirm mit\n• Sonst → lass den Schirm zu Hause\n\nWichtig: Der else-Block hat KEINE eigene Bedingung!\nEr fängt einfach ALLES auf, was nicht true war.',
    code: '// Einfaches if-else\nint alter = 15;\nif (alter >= 18) {\n    System.out.println("Volljährig");\n} else {\n    System.out.println("Minderjährig");\n}\n// Ausgabe: "Minderjährig"\n\n// Mit Zuweisung\nint temperatur = 30;\nString kleidung;\nif (temperatur > 25) {\n    kleidung = "T-Shirt";\n} else {\n    kleidung = "Jacke";\n}\nSystem.out.println(kleidung);  // "T-Shirt"\n\n// Gerade/Ungerade prüfen\nint zahl = 7;\nif (zahl % 2 == 0) {\n    System.out.println(zahl + " ist gerade");\n} else {\n    System.out.println(zahl + " ist ungerade");\n}\n// Ausgabe: "7 ist ungerade"'
  },
  {
    title: 'if-else-if-Kette – Mehrere Bedingungen',
    content: 'Wenn du MEHR als zwei Möglichkeiten prüfen willst, verwendest du eine if-else-if-Kette.\n\nSyntax:\n   if (bedingung1) {\n       // Block 1\n   } else if (bedingung2) {\n       // Block 2\n   } else if (bedingung3) {\n       // Block 3\n   } else {\n       // Auffangblock (optional)\n   }\n\nWICHTIGE REGELN:\n1. Die Bedingungen werden VON OBEN NACH UNTEN geprüft\n2. Der ERSTE Block, dessen Bedingung true ist, wird ausgeführt\n3. Alle weiteren Bedingungen werden dann ÜBERSPRUNGEN!\n4. Der else-Block am Ende ist optional – er fängt alles auf, was keine Bedingung erfüllt\n\nHäufiger Fehler: Reihenfolge beachten!\n   if (note <= 4) ... → Das wäre für Note 1, 2, 3 UND 4 true!\n   Wenn du 1 separat prüfen willst, muss es VOR dem <= 4 stehen.\n\nDarum immer von der SPEZIFISCHSTEN zur ALLGEMEINSTEN Bedingung ordnen.',
    code: '// Notenberechnung – typisches Beispiel\nint punkte = 75;\nString note;\n\nif (punkte >= 90) {\n    note = "Sehr gut";\n} else if (punkte >= 75) {\n    note = "Gut";\n} else if (punkte >= 60) {\n    note = "Befriedigend";\n} else if (punkte >= 50) {\n    note = "Ausreichend";\n} else {\n    note = "Nicht bestanden";\n}\nSystem.out.println(note);  // "Gut"\n\n// Reihenfolge ist wichtig!\nint x = 95;\n// FALSCH: x >= 50 ist auch für 95 true!\nif (x >= 50) {\n    System.out.println("Bestanden");  // Das wird genommen!\n} else if (x >= 90) {\n    System.out.println("Sehr gut");   // Wird nie erreicht!\n}'
  },
  {
    title: 'switch-case mit break',
    content: 'switch ist eine Alternative zu langen if-else-if-Ketten, wenn du einen EINZELNEN WERT mit verschiedenen Möglichkeiten vergleichst.\n\nSyntax:\n   switch (variable) {\n       case wert1:\n           // Code für wert1\n           break;\n       case wert2:\n           // Code für wert2\n           break;\n       default:\n           // Code wenn kein case passt\n   }\n\nErlaubte Typen für die Variable: int, byte, short, char, String, enum\n(NICHT: long, float, double, boolean!)\n\nDas Schlüsselwort break ist EXTREM WICHTIG!\nOhne break tritt FALL-THROUGH auf: Java führt ALLE folgenden Fälle aus,\nbis es auf ein break trifft oder das switch endet!\n\nFall-Through Beispiel:\n   case 1: print("A");      // Kein break!\n   case 2: print("B");      // Wird auch ausgeführt!\n   case 3: print("C");      // Wird auch ausgeführt!\n   → Wenn Wert 1 zutrifft, wird "ABC" ausgegeben!\n\ndefault ist wie else – es fängt alle nicht abgedeckten Fälle auf.\ndefault braucht kein break, wenn es am Ende steht.',
    code: '// switch mit break (korrekt)\nint tag = 3;\nswitch (tag) {\n    case 1: System.out.println("Montag"); break;\n    case 2: System.out.println("Dienstag"); break;\n    case 3: System.out.println("Mittwoch"); break;\n    default: System.out.println("Anderer Tag");\n}\n// Ausgabe: "Mittwoch"\n\n// FALL-THROUGH FALLE – ohne break!\nint x = 2;\nswitch (x) {\n    case 1: System.out.print("A");\n    case 2: System.out.print("B");\n    case 3: System.out.print("C");\n    default: System.out.print("D");\n}\n// Ausgabe: "BCD" (alles ab case 2!)\n\n// switch mit String\nString farbe = "rot";\nswitch (farbe) {\n    case "rot":   System.out.println("Stopp!"); break;\n    case "grün":  System.out.println("Los!"); break;\n    case "gelb":  System.out.println("Achtung!"); break;\n    default:      System.out.println("Unbekannt");\n}'
  },
  {
    title: 'Switch-Expressions (Java 14+)',
    content: 'Ab Java 14 gibt es eine modernere switch-Syntax mit dem Pfeil-Operator (->).\n\nVorteile gegenüber dem klassischen switch:\n1. KEIN break nötig – es gibt KEIN Fall-Through!\n2. Kann direkt einen WERT ZURÜCKGEBEN\n3. Kürzere und sicherere Syntax\n\nSyntax:\n   var ergebnis = switch (variable) {\n       case wert1 -> "Ergebnis 1";\n       case wert2 -> "Ergebnis 2";\n       default -> "Standard";\n   };\n\nWICHTIG: Wenn der switch einen Wert zurückgibt, MUSS ein Semikolon\nnach der schließenden geschweiften Klammer stehen!\n\nMehrere Werte pro case:\n   case 1, 2, 3 -> "Niedrig";\n   (Statt drei separate cases zu schreiben)\n\nMit Codeblock (für mehrere Anweisungen):\n   case 1 -> {\n       System.out.println("Eins");\n       yield "Ergebnis";  // yield statt return!\n   }\n\nDas Schlüsselwort yield wird verwendet, um aus einem Block einen Wert zurückzugeben.',
    code: '// Switch-Expression mit Pfeil-Syntax\nint tag = 3;\nString name = switch (tag) {\n    case 1 -> "Montag";\n    case 2 -> "Dienstag";\n    case 3 -> "Mittwoch";\n    case 4 -> "Donnerstag";\n    case 5 -> "Freitag";\n    default -> "Wochenende";\n};\nSystem.out.println(name);  // "Mittwoch"\n\n// Mehrere Werte pro case\nString typ = switch (tag) {\n    case 1, 2, 3, 4, 5 -> "Arbeitstag";\n    case 6, 7 -> "Wochenende";\n    default -> "Ungültig";\n};\n\n// Vergleich: Alt vs. Neu\n// ALT (mit Fall-Through-Gefahr):\nswitch (tag) {\n    case 1: System.out.println("Mo"); break;\n    case 2: System.out.println("Di"); break;\n}\n// NEU (sicher, kein break nötig):\nswitch (tag) {\n    case 1 -> System.out.println("Mo");\n    case 2 -> System.out.println("Di");\n}'
  },
  {
    title: 'Verschachtelte Bedingungen',
    content: 'Du kannst if-Anweisungen INNERHALB anderer if-Anweisungen schreiben. Das nennt man Verschachtelung.\n\nBeispiel:\n   if (x > 0) {\n       if (x > 100) {\n           // x ist positiv UND größer als 100\n       } else {\n           // x ist positiv, aber nicht größer als 100\n       }\n   } else {\n       // x ist 0 oder negativ\n   }\n\nWichtige Regel: Ein else gehört IMMER zum NÄCHSTEN if davor (ohne else).\nDas nennt man das "Dangling Else"-Problem.\n\nTipp: Zu viele Verschachtelungen machen den Code schwer lesbar.\nVereinfachungsmöglichkeiten:\n\n1. Mit && kombinieren:\n   Statt: if (a > 0) { if (b > 0) { ... } }\n   Besser: if (a > 0 && b > 0) { ... }\n\n2. Early Return / Guard Clause:\n   Statt tief zu verschachteln, prüfe ungültige Fälle zuerst ab\n   und kehre früh zurück.\n\nFaustregel: Mehr als 3 Ebenen Verschachtelung → Code umstrukturieren!',
    code: '// Verschachtelte Bedingung\nint alter = 25;\nboolean hatFuehrerschein = true;\n\nif (alter >= 18) {\n    if (hatFuehrerschein) {\n        System.out.println("Darf Auto fahren");\n    } else {\n        System.out.println("Erst Führerschein machen!");\n    }\n} else {\n    System.out.println("Zu jung zum Fahren");\n}\n\n// BESSER mit && vereinfacht:\nif (alter >= 18 && hatFuehrerschein) {\n    System.out.println("Darf Auto fahren");\n} else if (alter >= 18) {\n    System.out.println("Erst Führerschein machen!");\n} else {\n    System.out.println("Zu jung zum Fahren");\n}'
  },
  {
    title: 'Häufiger Fehler: = vs ==',
    content: 'Einer der häufigsten Fehler von Anfängern ist die Verwechslung von = und ==.\n\n= ist der ZUWEISUNGSOPERATOR:\n   x = 5;   → Speichert den Wert 5 in der Variable x\n\n== ist der VERGLEICHSOPERATOR:\n   x == 5   → Prüft, ob x den Wert 5 hat (ergibt true oder false)\n\nWas passiert, wenn du = statt == in einer if-Bedingung verwendest?\n\n   int x = 3;\n   if (x = 5) { ... }   → COMPILERFEHLER!\n\nWarum? Die Zuweisung x = 5 hat den Rückgabewert 5 (ein int).\nAber if erwartet einen boolean-Ausdruck! Ein int ist kein boolean → Fehler!\n\nACHTUNG: In der Sprache C würde das kompilieren und als "true" gelten!\nJava ist hier strenger und schützt dich vor diesem Fehler.\n\nBei boolean-Variablen wäre es allerdings gültig (aber trotzdem falsch):\n   boolean b = false;\n   if (b = true) { ... }  → Kompiliert! b wird auf true gesetzt, if ist true.\n   Das ist ein logischer Fehler, kein Compilerfehler!\n\nTipp: Schreibe bei Vergleichen die Konstante links:\n   if (5 == x) statt if (x == 5)\n   So bekommst du bei versehentlichem = sofort einen Fehler.',
    code: '// RICHTIG: Vergleich mit ==\nint x = 3;\nif (x == 5) {\n    System.out.println("x ist 5");\n} else {\n    System.out.println("x ist nicht 5");\n}\n// Ausgabe: "x ist nicht 5"\n\n// FALSCH: Zuweisung statt Vergleich\n// if (x = 5) { }  // COMPILERFEHLER bei int!\n\n// GEFAHR bei boolean:\nboolean aktiv = false;\nif (aktiv = true) {   // ACHTUNG: Zuweisung, nicht Vergleich!\n    System.out.println("Wird ausgeführt!");  // Wird ausgegeben!\n}\n// aktiv ist jetzt true (wurde zugewiesen, nicht verglichen!)\n\n// Korrekt wäre:\nif (aktiv == true) { }  // Vergleich\n// Oder noch besser:\nif (aktiv) { }          // Direkt den boolean verwenden'
  }
];
