export const theory = [
  {
    title: 'Arithmetische Operatoren',
    content: 'Java bietet die fünf Grundrechenarten:\n• + Addition\n• - Subtraktion\n• * Multiplikation\n• / Division\n• % Modulo (Rest der Division)\n\nDIE WICHTIGSTE FALLE – Ganzzahldivision:\nWenn BEIDE Operanden Ganzzahlen (int) sind, wird das Ergebnis ABGESCHNITTEN!\n   5 / 2 = 2     (NICHT 2.5! Der Nachkommateil fällt weg!)\n   7 / 3 = 2     (NICHT 2.33!)\n   1 / 3 = 0     (NICHT 0.33!)\n\nSobald EIN Operand ein double/float ist, wird Gleitkommadivision verwendet:\n   5.0 / 2 = 2.5    (double / int = double)\n   5 / 2.0 = 2.5    (int / double = double)\n\nTrick: Wenn du aus zwei ints ein double-Ergebnis willst, caste einen:\n   (double) 5 / 2 = 2.5\n\nModulo (%) – Der Rest nach der Division:\n   10 % 3 = 1    (10 / 3 = 3 Rest 1)\n   7 % 2 = 1     (7 / 2 = 3 Rest 1)\n   8 % 2 = 0     (8 / 2 = 4 Rest 0)\n\nPraktische Anwendung: Gerade/Ungerade prüfen!\n   zahl % 2 == 0 → gerade\n   zahl % 2 != 0 → ungerade',
    code: '// Grundrechenarten\nSystem.out.println(10 + 3);   // 13\nSystem.out.println(10 - 3);   // 7\nSystem.out.println(10 * 3);   // 30\n\n// GANZZAHLDIVISION – die Falle!\nSystem.out.println(5 / 2);      // 2 (NICHT 2.5!)\nSystem.out.println(1 / 3);      // 0 (NICHT 0.33!)\nSystem.out.println(5.0 / 2);    // 2.5 (ein double dabei → double)\nSystem.out.println((double) 5 / 2); // 2.5 (Cast-Trick)\n\n// Modulo – Rest der Division\nSystem.out.println(10 % 3);    // 1\nSystem.out.println(7 % 2);     // 1 (ungerade!)\nSystem.out.println(8 % 2);     // 0 (gerade!)'
  },
  {
    title: 'Zuweisungsoperatoren',
    content: 'Der einfache Zuweisungsoperator = speichert einen Wert in einer Variable.\n\nDaneben gibt es zusammengesetzte Zuweisungsoperatoren – diese kombinieren eine Berechnung mit der Zuweisung:\n\n• x += 3   ist dasselbe wie   x = x + 3\n• x -= 3   ist dasselbe wie   x = x - 3\n• x *= 3   ist dasselbe wie   x = x * 3\n• x /= 3   ist dasselbe wie   x = x / 3\n• x %= 3   ist dasselbe wie   x = x % 3\n\nDer Vorteil: Kürzer und übersichtlicher.\nStatt "nimm x, addiere 3, speichere in x" schreibst du einfach "x += 3".\n\nWichtig: Die zusammengesetzten Operatoren machen auch implizites Casting!\n   byte b = 10;\n   b += 5;      // Funktioniert! (internes Casting)\n   b = b + 5;   // COMPILERFEHLER! (b + 5 ergibt int, passt nicht in byte)\n\nDas liegt daran, dass b += 5 intern als b = (byte)(b + 5) behandelt wird.',
    code: '// Einfache Zuweisung\nint x = 10;\n\n// Zusammengesetzte Zuweisungsoperatoren\nx += 5;   // x = x + 5 → x ist 15\nx -= 3;   // x = x - 3 → x ist 12\nx *= 2;   // x = x * 2 → x ist 24\nx /= 4;   // x = x / 4 → x ist 6\nx %= 4;   // x = x % 4 → x ist 2\n\n// Implizites Casting bei zusammengesetzten Operatoren\nbyte b = 10;\nb += 5;       // OK! Wird intern zu: b = (byte)(b + 5)\n// b = b + 5;  // COMPILERFEHLER! b + 5 ergibt int'
  },
  {
    title: 'Vergleichsoperatoren',
    content: 'Vergleichsoperatoren vergleichen zwei Werte und geben IMMER einen boolean (true oder false) zurück:\n\n• ==  gleich           (5 == 5 → true)\n• !=  ungleich         (5 != 3 → true)\n• >   größer als       (5 > 3 → true)\n• <   kleiner als      (3 < 5 → true)\n• >=  größer oder gleich (5 >= 5 → true)\n• <=  kleiner oder gleich (3 <= 5 → true)\n\nACHTUNG bei Objekten (z.B. Strings):\n• == vergleicht die REFERENZ (Speicheradresse) → Zeigen beide auf dasselbe Objekt?\n• .equals() vergleicht den INHALT → Ist der Wert gleich?\n\nFür primitive Typen (int, double usw.) ist == völlig in Ordnung.\nFür Objekte (String, Integer usw.) verwende IMMER .equals() für Inhaltsvergleiche!\n\nBeispiel für die Falle:\n   String a = new String("Hi");\n   String b = new String("Hi");\n   a == b       → false (verschiedene Objekte im Speicher!)\n   a.equals(b)  → true (gleicher Inhalt "Hi")',
    code: '// Vergleichsoperatoren mit primitiven Typen\nSystem.out.println(5 == 5);    // true\nSystem.out.println(5 != 3);    // true\nSystem.out.println(5 > 3);     // true\nSystem.out.println(3 < 5);     // true\nSystem.out.println(5 >= 5);    // true\nSystem.out.println(3 <= 5);    // true\n\n// Die Falle bei Objekten\nString a = new String("Hallo");\nString b = new String("Hallo");\nSystem.out.println(a == b);       // false! (verschiedene Objekte)\nSystem.out.println(a.equals(b));  // true!  (gleicher Inhalt)\n\n// Bei primitiven Typen ist == korrekt\nint x = 5;\nint y = 5;\nSystem.out.println(x == y);       // true (Wertvergleich)'
  },
  {
    title: 'Logische Operatoren',
    content: 'Logische Operatoren verknüpfen boolean-Werte:\n\n1. && (UND / AND) – Beide müssen true sein:\n   true  && true  = true\n   true  && false = false\n   false && true  = false\n   false && false = false\n   Merke: Sobald ein false dabei ist → Ergebnis ist false\n\n2. || (ODER / OR) – Mindestens einer muss true sein:\n   true  || true  = true\n   true  || false = true\n   false || true  = true\n   false || false = false\n   Merke: Sobald ein true dabei ist → Ergebnis ist true\n\n3. ! (NICHT / NOT) – Dreht den Wert um:\n   !true  = false\n   !false = true\n\nPraktische Beispiele:\n   alter >= 18 && alter <= 65   → Ist das Alter zwischen 18 und 65?\n   tag == "Sa" || tag == "So"   → Ist es Wochenende?\n   !istGesperrt                 → Ist NICHT gesperrt?',
    code: '// UND (&&) – beide Bedingungen müssen true sein\nint alter = 25;\nboolean erwachsen = alter >= 18 && alter <= 65;  // true\n\n// ODER (||) – mindestens eine Bedingung muss true sein\nString tag = "Sa";\nboolean wochenende = tag.equals("Sa") || tag.equals("So"); // true\n\n// NICHT (!) – dreht den Wert um\nboolean gesperrt = false;\nboolean zugang = !gesperrt;  // true\n\n// Kombination\nboolean darfFahren = alter >= 18 && !gesperrt;  // true'
  },
  {
    title: 'Short-Circuit Evaluation',
    content: 'WICHTIGES KONZEPT für Prüfungen!\n\nShort-Circuit ("Kurzschluss-Auswertung") bedeutet:\nJava wertet den rechten Teil eines logischen Ausdrucks NICHT aus, wenn das Ergebnis bereits feststeht.\n\nBei && (UND):\n   false && (irgendwas) → Ergebnis ist IMMER false\n   → Java wertet die rechte Seite GAR NICHT aus!\n   Warum? Wenn die linke Seite false ist, kann && nie true werden.\n\nBei || (ODER):\n   true || (irgendwas) → Ergebnis ist IMMER true\n   → Java wertet die rechte Seite GAR NICHT aus!\n   Warum? Wenn die linke Seite true ist, ist || immer true.\n\nWarum ist das wichtig?\n1. Seiteneffekte werden NICHT ausgeführt!\n   false && (x++ > 0) → x wird NICHT erhöht!\n   true || (x++ > 0)  → x wird NICHT erhöht!\n\n2. Null-Prüfungen funktionieren dadurch:\n   if (s != null && s.length() > 0)\n   → Wenn s null ist, wird s.length() NICHT aufgerufen → kein Crash!\n\nDies ist eine der häufigsten Prüfungsfallen!',
    code: '// Short-Circuit bei &&\nint x = 0;\nif (false && (++x > 0)) {}\nSystem.out.println(x);  // 0 (x wurde NICHT erhöht!)\n\n// Short-Circuit bei ||\nint y = 0;\nif (true || (++y > 0)) {}\nSystem.out.println(y);  // 0 (y wurde NICHT erhöht!)\n\n// OHNE Short-Circuit (linke Seite ist true bei &&)\nint z = 0;\nif (true && (++z > 0)) {}\nSystem.out.println(z);  // 1 (z WURDE erhöht!)\n\n// Praktischer Nutzen: Null-Sicherheit\nString s = null;\nif (s != null && s.length() > 0) {\n    // s.length() wird nur aufgerufen wenn s NICHT null ist\n    System.out.println(s);\n}'
  },
  {
    title: 'Inkrement und Dekrement',
    content: 'Inkrement (++) erhöht um 1, Dekrement (--) verringert um 1.\nEs gibt zwei Varianten – und der Unterschied ist WICHTIG:\n\nPost-Inkrement: i++\n   → Erst den AKTUELLEN Wert verwenden, DANN um 1 erhöhen\n   → "Benutze mich, dann erhöhe mich"\n\nPre-Inkrement: ++i\n   → Erst um 1 erhöhen, DANN den NEUEN Wert verwenden\n   → "Erhöhe mich, dann benutze mich"\n\nSchritt-für-Schritt-Beispiel:\n   int i = 5;\n   System.out.println(i++);  // Gibt 5 aus (alter Wert), i ist jetzt 6\n   System.out.println(i);    // Gibt 6 aus\n\n   int j = 5;\n   System.out.println(++j);  // Gibt 6 aus (neuer Wert), j ist jetzt 6\n\nKomplexeres Beispiel:\n   int a = 3;\n   int b = a++ + ++a;\n   // a++ → Wert 3 wird genommen, a wird zu 4\n   // ++a → a wird zu 5, Wert 5 wird genommen\n   // b = 3 + 5 = 8, a = 5\n\nDasselbe gilt für -- (Dekrement) mit Minus statt Plus.',
    code: '// Post-Inkrement (i++) – erst benutzen, dann erhöhen\nint i = 5;\nSystem.out.println(i++);   // Ausgabe: 5 (alter Wert)\nSystem.out.println(i);     // Ausgabe: 6 (jetzt erhöht)\n\n// Pre-Inkrement (++i) – erst erhöhen, dann benutzen\nint j = 5;\nSystem.out.println(++j);   // Ausgabe: 6 (neuer Wert)\n\n// Dekrement funktioniert gleich\nint k = 10;\nSystem.out.println(k--);   // Ausgabe: 10, k ist jetzt 9\nSystem.out.println(--k);   // Ausgabe: 8 (erst -1, dann ausgeben)\n\n// In Zuweisungen\nint a = 5;\nint b = a++;  // b = 5 (alter Wert von a), a = 6\nint c = ++a;  // a = 7, c = 7 (neuer Wert von a)'
  },
  {
    title: 'Ternärer Operator',
    content: 'Der ternäre Operator ist eine Kurzform für eine einfache if-else-Entscheidung.\nEr heißt "ternär", weil er DREI Teile hat:\n\n   Bedingung ? wertWennTrue : wertWennFalse\n\nSo funktioniert es:\n1. Die Bedingung wird geprüft\n2. Wenn true → der Wert VOR dem Doppelpunkt wird zurückgegeben\n3. Wenn false → der Wert NACH dem Doppelpunkt wird zurückgegeben\n\nVergleich mit if-else:\n   // Mit if-else (4 Zeilen):\n   String status;\n   if (alter >= 18) {\n       status = "volljährig";\n   } else {\n       status = "minderjährig";\n   }\n\n   // Mit ternärem Operator (1 Zeile):\n   String status = (alter >= 18) ? "volljährig" : "minderjährig";\n\nTipps:\n• Verwende den ternären Operator nur für EINFACHE Entscheidungen\n• Bei komplexerer Logik ist if-else lesbarer\n• Man kann ihn auch direkt in println() verwenden',
    code: '// Einfaches Beispiel\nint alter = 20;\nString status = (alter >= 18) ? "volljährig" : "minderjährig";\nSystem.out.println(status);  // "volljährig"\n\n// Direkt in println\nint note = 3;\nSystem.out.println(note <= 4 ? "Bestanden" : "Durchgefallen");\n\n// Mit Zahlen\nint a = 10, b = 20;\nint max = (a > b) ? a : b;  // max = 20\n\n// Verschachtelt (aber besser if-else verwenden!)\nString ergebnis = (note == 1) ? "Sehr gut"\n    : (note == 2) ? "Gut"\n    : "Andere Note";'
  },
  {
    title: 'String-Konkatenation mit +',
    content: 'Der +-Operator hat bei Strings eine besondere Bedeutung: Er verkettet (verbindet) Strings.\n\nDIE WICHTIGSTE REGEL:\nDer Ausdruck wird VON LINKS NACH RECHTS ausgewertet.\nSobald EIN Operand ein String ist, wird der andere auch zu einem String konvertiert.\n\nDadurch entstehen überraschende Ergebnisse – eine KLASSISCHE PRÜFUNGSFALLE:\n\n   5 + 3 + "ha"    → Ergebnis: "8ha"\n   Warum? 5 + 3 = 8 (beides int → Zahlenaddition)\n          8 + "ha" = "8ha" (int + String → Konkatenation)\n\n   "ha" + 5 + 3    → Ergebnis: "ha53"\n   Warum? "ha" + 5 = "ha5" (String + int → Konkatenation)\n          "ha5" + 3 = "ha53" (String + int → Konkatenation)\n\nWeitere Beispiele:\n   1 + 2 + "+" + 3 + 4  → "3+34"\n   (1+2) = 3, 3+"+" = "3+", "3+"+3 = "3+3", "3+3"+4 = "3+34"\n\nTrick mit Klammern:\n   "Ergebnis: " + (5 + 3) → "Ergebnis: 8"\n   Die Klammern erzwingen, dass 5+3 zuerst als Zahlenaddition berechnet wird.',
    code: '// Von links nach rechts – die Falle!\nSystem.out.println(5 + 3 + "ha");     // "8ha"\nSystem.out.println("ha" + 5 + 3);     // "ha53"\nSystem.out.println("ha" + (5 + 3));   // "ha8" (Klammern!)\nSystem.out.println(1 + 2 + "+" + 3 + 4); // "3+34"\n\n// String mit verschiedenen Typen\nint alter = 25;\nSystem.out.println("Alter: " + alter);           // "Alter: 25"\nSystem.out.println("Pi: " + 3.14);               // "Pi: 3.14"\nSystem.out.println("Wahr: " + true);             // "Wahr: true"\nSystem.out.println("Zeichen: " + \'A\');           // "Zeichen: A"'
  },
  {
    title: 'Operator-Rangfolge (Präzedenz)',
    content: 'Wie in der Mathematik gibt es auch in Java eine Reihenfolge, in der Operatoren ausgewertet werden.\nRegel: Operatoren mit HÖHERER Priorität werden ZUERST ausgewertet.\n\nVon HOCH nach NIEDRIG:\n1. Klammern ()             → IMMER zuerst!\n2. Unäre: ++, --, !        → z.B. !true, i++\n3. Multiplikativ: *, /, %  → Punkt vor Strich!\n4. Additiv: +, -           → Strichrechnung\n5. Vergleich: <, >, <=, >= → Größenvergleiche\n6. Gleichheit: ==, !=      → Gleichheitsprüfung\n7. Logisches UND: &&\n8. Logisches ODER: ||\n9. Ternär: ? :\n10. Zuweisung: =, +=, -=   → NIEDRIGSTE Priorität\n\nWichtige Beispiele:\n• 1 + 2 * 3 = 7      (nicht 9! → * vor +)\n• !true && false = false  (erst !true = false, dann false && false)\n• true || true && false = true  (&& vor || → true && false = false, dann true || false = true)\n\nIm Zweifel: KLAMMERN SETZEN! Das macht den Code lesbarer.',
    code: '// Punkt vor Strich\nSystem.out.println(1 + 2 * 3);     // 7 (nicht 9!)\nSystem.out.println((1 + 2) * 3);   // 9 (Klammern!)\n\n// ! vor && vor ||\nSystem.out.println(!true && false);           // false\nSystem.out.println(true || true && false);    // true\n// Erklärung: && vor || → true || (true && false)\n//                      → true || false → true\n\n// Komplexes Beispiel\nint x = 2;\nSystem.out.println(x + 3 * 2 > 10 - x && x != 0);\n// 3*2=6, x+6=8, 10-x=8, 8>8=false, false&&true=false'
  }
];
