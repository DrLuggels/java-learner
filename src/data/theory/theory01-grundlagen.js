export const theory = [
  {
    title: 'Was ist Java? JDK, JRE, JVM',
    content: 'Java ist eine objektorientierte, plattformunabhängige Programmiersprache.\nDas bedeutet: Du schreibst deinen Code einmal und kannst ihn auf jedem Betriebssystem ausführen – Windows, Mac, Linux. Das nennt man "Write once, run anywhere".\n\nUm das zu verstehen, musst du drei Begriffe kennen:\n\n1. JDK (Java Development Kit) – Das Werkzeugset für Entwickler\n   - Enthält den Compiler (javac), der deinen Code übersetzt\n   - Enthält Debugging-Tools und andere Hilfsprogramme\n   - Du brauchst das JDK, um Java-Programme zu SCHREIBEN und zu kompilieren\n\n2. JRE (Java Runtime Environment) – Die Laufzeitumgebung\n   - Enthält alles, was man braucht, um Java-Programme AUSZUFÜHREN\n   - Enthält die Java-Klassenbibliothek (fertige Klassen wie String, Math usw.)\n   - Ist im JDK bereits enthalten\n\n3. JVM (Java Virtual Machine) – Die virtuelle Maschine\n   - Führt den Bytecode aus\n   - Ist für jedes Betriebssystem anders implementiert\n   - Deshalb funktioniert Java überall: Jedes OS hat seine eigene JVM\n\nDer Kompilierungsablauf Schritt für Schritt:\n  Quellcode (.java) → javac (Compiler) → Bytecode (.class) → JVM führt aus\n\nBeispiel: Du schreibst Main.java → javac erzeugt Main.class → JVM liest Main.class und führt es aus.',
    code: '// Schritt 1: Du schreibst eine Datei "Main.java"\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println("Hallo Welt!");\n    }\n}\n\n// Schritt 2: Kompilieren in der Konsole\n// > javac Main.java    (erzeugt Main.class)\n\n// Schritt 3: Ausführen\n// > java Main           (JVM führt Bytecode aus)\n// Ausgabe: Hallo Welt!'
  },
  {
    title: 'Aufbau einer Java-Klasse',
    content: 'Jede Java-Datei enthält mindestens eine Klasse. Lass uns jedes Element einzeln verstehen:\n\npublic class MeinProgramm {\n    public static void main(String[] args) {\n        System.out.println("Hallo!");\n    }\n}\n\nZeile für Zeile erklärt:\n\n• public – Zugriffsmodifikator: Die Klasse ist von überall sichtbar\n• class – Schlüsselwort: Sagt Java "hier kommt eine Klasse"\n• MeinProgramm – Name der Klasse (Konvention: UpperCamelCase, z.B. MeinAutoShop)\n  WICHTIG: Der Dateiname MUSS exakt dem Klassennamen entsprechen! → MeinProgramm.java\n• { } – Geschweifte Klammern begrenzen den Körper der Klasse\n\nDie main-Methode ist der Einstiegspunkt – hier startet das Programm:\n• public – Von außen aufrufbar (die JVM muss sie aufrufen können)\n• static – Gehört zur Klasse, nicht zu einem Objekt (kein Objekt nötig zum Starten)\n• void – Kein Rückgabewert\n• main – Exakter Name, den die JVM sucht\n• String[] args – Parameter: Ein Array von Strings (Kommandozeilenargumente)\n\nSystem.out.println() erklärt:\n• System – Eine Klasse aus der Standardbibliothek\n• out – Ein statisches Feld (der Standard-Ausgabestrom)\n• println() – Methode: "print line" – gibt Text aus und macht einen Zeilenumbruch\n• print() ohne "ln" macht KEINEN Zeilenumbruch danach',
    code: '// Minimales Java-Programm\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println("Hallo Welt!");  // Mit Zeilenumbruch\n        System.out.print("Kein ");          // Ohne Zeilenumbruch\n        System.out.print("Umbruch");        // Direkt dahinter\n        // Ausgabe: Kein Umbruch\n    }\n}'
  },
  {
    title: 'Primitive Datentypen',
    content: 'Java hat genau 8 primitive Datentypen. Stell dir diese wie verschiedene Behälter vor – jeder hat eine andere Größe:\n\nGanzzahlen (ohne Komma):\n• byte  →  8 Bit  → -128 bis 127 (für sehr kleine Zahlen, z.B. Alter)\n• short → 16 Bit  → -32.768 bis 32.767 (selten verwendet)\n• int   → 32 Bit  → ca. -2,1 Milliarden bis +2,1 Milliarden → STANDARDTYP für Ganzzahlen!\n• long  → 64 Bit  → riesiger Bereich → braucht ein L am Ende: long x = 123456789L;\n\nKommazahlen:\n• float  → 32 Bit → weniger genau → braucht ein f am Ende: float x = 3.14f;\n• double → 64 Bit → genauer → STANDARDTYP für Kommazahlen: double x = 3.14;\n\nAndere:\n• char    → 16 Bit → EIN einzelnes Zeichen in einfachen Anführungszeichen: char c = \'A\';\n  Jedes Zeichen hat einen Unicode/ASCII-Wert, z.B. \'A\' = 65, \'a\' = 97, \'0\' = 48\n  WICHTIG: char ist eigentlich eine Zahl! \'A\' + 1 ergibt 66 (nicht \'B\')!\n• boolean → true oder false (nichts anderes!) → für Wahrheitswerte\n\nMerke: int und double sind die Standards. Verwende die anderen nur bei Bedarf.',
    code: '// Ganzzahlen\nbyte alter = 25;              // -128 bis 127\nshort temperatur = -10;       // -32768 bis 32767\nint einwohner = 83000000;     // Standardtyp!\nlong weltbevoelkerung = 8000000000L;  // L nicht vergessen!\n\n// Kommazahlen\nfloat preis = 9.99f;          // f nicht vergessen!\ndouble pi = 3.14159265;       // Standardtyp!\n\n// Zeichen und Wahrheitswerte\nchar note = \'A\';              // Einfache Anführungszeichen!\nboolean bestanden = true;\n\n// char ist eine Zahl!\nSystem.out.println(\'A\' + 1);  // Ausgabe: 66 (nicht B!)\nSystem.out.println((char)(\'A\' + 1));  // Ausgabe: B'
  },
  {
    title: 'Wrapper-Klassen und Autoboxing',
    content: 'Für jeden primitiven Typ gibt es eine Wrapper-Klasse (eine "Verpackung" als Objekt):\n\n  int     → Integer\n  double  → Double\n  float   → Float\n  long    → Long\n  char    → Character   (Achtung: nicht "Char"!)\n  boolean → Boolean\n  byte    → Byte\n  short   → Short\n\nWarum braucht man Wrapper?\n1. Collections (z.B. ArrayList) können NUR Objekte speichern, keine primitiven Typen\n   → ArrayList<int> geht NICHT! → ArrayList<Integer> geht!\n2. Wrapper können null sein (primitives können das nicht)\n   → Integer x = null; ist erlaubt, int x = null; ist ein Fehler!\n3. Wrapper haben nützliche Methoden, z.B. Integer.parseInt("42") wandelt String zu int\n\nAutoboxing = Java wandelt automatisch primitiv → Wrapper:\n   Integer x = 5;  // Java macht heimlich: Integer x = Integer.valueOf(5);\n\nUnboxing = Java wandelt automatisch Wrapper → primitiv:\n   int y = x;      // Java macht heimlich: int y = x.intValue();\n\nACHTUNG: Unboxing von null erzeugt NullPointerException!\n   Integer x = null;\n   int y = x;  // CRASH! NullPointerException!',
    code: '// Autoboxing: primitiv → Wrapper (automatisch)\nInteger zahl = 42;        // int → Integer\nDouble komma = 3.14;      // double → Double\nBoolean wahr = true;      // boolean → Boolean\n\n// Unboxing: Wrapper → primitiv (automatisch)\nint a = zahl;             // Integer → int\ndouble b = komma;         // Double → double\n\n// Wrapper können null sein\nInteger c = null;         // Erlaubt!\n// int d = c;             // CRASH: NullPointerException!\n\n// Nützliche Methoden\nint parsed = Integer.parseInt("123");     // String → int\nString text = Integer.toString(42);       // int → String\nint max = Integer.MAX_VALUE;              // 2147483647'
  },
  {
    title: 'Typumwandlung (Casting)',
    content: 'Stell dir Datentypen wie unterschiedlich große Eimer vor:\n  byte → short → int → long → float → double (klein → groß)\n\n1. Implizites Casting (Widening) – AUTOMATISCH, SICHER\n   Von kleinerem zu größerem Typ. Kein Datenverlust.\n   int x = 5; double d = x;  → d ist 5.0 (automatisch umgewandelt)\n\n2. Explizites Casting (Narrowing) – MANUELL, KANN DATEN VERLIEREN!\n   Von größerem zu kleinerem Typ. Du musst den Zieltyp in Klammern schreiben.\n   double d = 3.9; int x = (int) d;  → x ist 3!\n\n   GANZ WICHTIG: Beim Casting von double zu int wird ABGESCHNITTEN,\n   NICHT gerundet! 3.9 wird zu 3, nicht zu 4!\n   Der Nachkommateil fällt einfach weg.\n\n   Weiteres Beispiel: (int) -2.7 ergibt -2 (nicht -3!)\n\n3. Überlauf bei Narrowing:\n   int grosseZahl = 130; byte b = (byte) grosseZahl;\n   → b ist NICHT 130 (byte geht nur bis 127), es kommt zu einem Überlauf!\n\nWichtig: Bei Berechnungen wird automatisch zum größeren Typ erweitert:\n   5 / 2 = 2      (int / int = int, abgeschnitten!)\n   5.0 / 2 = 2.5  (double / int = double)',
    code: '// Implizites Casting (automatisch, sicher)\nint ganzzahl = 42;\ndouble komma = ganzzahl;     // 42 → 42.0 (automatisch)\n\nbyte klein = 10;\nint gross = klein;           // automatisch: byte → int\n\n// Explizites Casting (manuell, kann Daten verlieren!)\ndouble pi = 3.99;\nint gerundet = (int) pi;     // 3 (NICHT 4! Abgeschnitten!)\n\ndouble negativ = -2.7;\nint neg = (int) negativ;     // -2 (NICHT -3!)\n\n// Ganzzahldivision vs. Gleitkommadivision\nSystem.out.println(5 / 2);     // 2 (int / int = int)\nSystem.out.println(5.0 / 2);   // 2.5 (double / int = double)\nSystem.out.println((double) 5 / 2);  // 2.5 (Cast vor Division)'
  },
  {
    title: 'Variablen und Konstanten',
    content: 'Eine Variable ist wie ein beschrifteter Behälter, der einen Wert speichert.\n\nDeklaration (Behälter erstellen):\n   int alter;          // Variable vom Typ int mit Namen "alter"\n\nInitialisierung (Wert zuweisen):\n   alter = 25;         // Wert 25 in den Behälter legen\n\nDeklaration + Initialisierung in einem Schritt:\n   int alter = 25;     // Beides gleichzeitig\n\nNamenskonventionen:\n• Variablen: camelCase → meinAlter, anzahlStudenten, istBestanden\n• Beginnen mit Kleinbuchstabe\n• Keine Leerzeichen, keine Sonderzeichen (außer _ und $)\n• Dürfen NICHT mit einer Zahl beginnen: 2name ist ungültig!\n\nKonstanten mit final:\n• final macht eine Variable unveränderlich → sie wird zur Konstante\n• Nach der ersten Zuweisung kann der Wert NICHT mehr geändert werden\n• Konvention: UPPER_SNAKE_CASE → final int MAX_WERT = 100;\n• Versuch einer Neuzuweisung → Compilerfehler!',
    code: '// Deklaration und Initialisierung\nint alter;              // Nur Deklaration\nalter = 25;             // Initialisierung\nString name = "Anna";   // Beides zusammen\n\n// Mehrere Variablen vom gleichen Typ\nint x = 1, y = 2, z = 3;\n\n// Konstanten mit final\nfinal double PI = 3.14159;\nfinal int MAX_SPIELER = 11;\nfinal String BEGRUESSUNG = "Hallo";\n\n// PI = 3.0;  // COMPILERFEHLER! final kann nicht geändert werden!\n\n// Namenskonventionen\nint meinAlter = 25;          // camelCase für Variablen\nfinal int MAX_WERT = 100;    // UPPER_SNAKE_CASE für Konstanten'
  },
  {
    title: 'Strings – Zeichenketten',
    content: 'Strings sind KEINE primitiven Datentypen – sie sind Objekte der Klasse String!\nSie werden mit doppelten Anführungszeichen erstellt: "Hallo"\n\nWichtige Eigenschaft: Strings sind UNVERÄNDERLICH (immutable)!\nJede "Änderung" erzeugt einen neuen String im Speicher.\n\nWichtige String-Methoden:\n• length()          → Anzahl der Zeichen: "Hallo".length() → 5\n• charAt(index)     → Zeichen an Position: "Hallo".charAt(0) → \'H\' (Index beginnt bei 0!)\n• substring(von, bis) → Teilstring: "Hallo".substring(0, 3) → "Hal" (bis ist exklusiv!)\n• equals(anderer)   → Inhalt vergleichen: "Hi".equals("Hi") → true\n• equalsIgnoreCase() → Vergleich ohne Groß/Klein: "hi".equalsIgnoreCase("HI") → true\n• toUpperCase()     → Alles groß: "hallo".toUpperCase() → "HALLO"\n• toLowerCase()     → Alles klein: "HALLO".toLowerCase() → "hallo"\n• contains(text)    → Enthält?: "Hallo Welt".contains("Welt") → true\n• indexOf(text)     → Position finden: "Hallo".indexOf("ll") → 2 (oder -1 wenn nicht gefunden)\n• trim()            → Leerzeichen am Rand entfernen: "  Hi  ".trim() → "Hi"\n\nDIE WICHTIGSTE FALLE:\n• == vergleicht REFERENZEN (Speicheradresse) → Sind es dasselbe Objekt?\n• equals() vergleicht INHALT → Ist der Text gleich?\nFür Strings IMMER equals() verwenden!',
    code: '// String-Methoden\nString s = "Hallo Welt";\ns.length();           // 10\ns.charAt(0);          // \'H\'\ns.substring(0, 5);    // "Hallo" (Index 5 ist exklusiv!)\ns.contains("Welt");   // true\ns.indexOf("Welt");    // 6\ns.toUpperCase();      // "HALLO WELT"\n\n// DIE FALLE: == vs. equals()\nString a = new String("Test");\nString b = new String("Test");\nSystem.out.println(a == b);      // false! (verschiedene Objekte)\nSystem.out.println(a.equals(b)); // true!  (gleicher Inhalt)\n\n// Darum IMMER equals() für String-Vergleiche!\nString name = "Anna";\nif (name.equals("Anna")) {     // RICHTIG\n    System.out.println("Gefunden!");\n}'
  },
  {
    title: 'Escape-Sequenzen und Binärzahlen',
    content: 'Escape-Sequenzen sind spezielle Zeichenkombinationen mit Backslash:\n\n• \\n → Zeilenumbruch (neue Zeile)\n• \\t → Tabulator (Einrückung)\n• \\\\ → Ein Backslash (weil \\ allein eine Escape-Sequenz einleitet)\n• \\" → Ein Anführungszeichen innerhalb eines Strings\n\nBinärzahlen (Zweiersystem):\nComputer rechnen intern mit 0 und 1. In Java schreibst du Binärzahlen mit dem Präfix 0b.\n\nSo rechnest du Binär → Dezimal um (Schritt für Schritt):\n  0b1010\n  Stelle:  3    2    1    0     (von rechts, bei 0 anfangen)\n  Wert:    2³   2²   2¹   2⁰    (Zweierpotenz)\n           8    4    2    1\n  Ziffer:  1    0    1    0\n  Rechne:  1×8 + 0×4 + 1×2 + 0×1 = 8 + 0 + 2 + 0 = 10\n\nAlso: 0b1010 = 10 dezimal\n\nWeiteres Beispiel:\n  0b1100 = 1×8 + 1×4 + 0×2 + 0×1 = 12\n  0b1111 = 1×8 + 1×4 + 1×2 + 1×1 = 15\n  0b10000 = 1×16 = 16',
    code: '// Escape-Sequenzen\nSystem.out.println("Zeile 1\\nZeile 2");\n// Ausgabe:\n// Zeile 1\n// Zeile 2\n\nSystem.out.println("Spalte1\\tSpalte2");\n// Ausgabe: Spalte1    Spalte2\n\nSystem.out.println("Er sagte: \\"Hallo\\"");\n// Ausgabe: Er sagte: "Hallo"\n\nSystem.out.println("Pfad: C:\\\\Users\\\\Ordner");\n// Ausgabe: Pfad: C:\\Users\\Ordner\n\n// Binärzahlen\nint a = 0b1010;    // = 10\nint b = 0b1100;    // = 12\nint c = 0b1111;    // = 15\nint d = 0b1010010; // = 1×64+0×32+1×16+0+0+1×2+0 = 82'
  }
];
