export const theory = [
  { title: 'Abstrakte Klasse', content: 'Eine abstrakte Klasse wird mit dem Schlüsselwort abstract deklariert. Sie kann nicht direkt instanziiert werden und kann abstrakte Methoden (ohne Implementierung) enthalten.', code: 'abstract class Tier {\n    abstract void sprechen();\n    void atmen() {\n        System.out.println("Atmet...");\n    }\n}' },
  { title: 'Abstrakte und konkrete Methoden', content: 'Eine abstrakte Klasse kann sowohl abstrakte Methoden (ohne Body) als auch konkrete Methoden (mit Body) haben. Unterklassen müssen alle abstrakten Methoden implementieren.' },
  { title: 'Finale Klasse und finale Methode', content: 'Eine finale Klasse (final class) kann nicht erweitert werden. Eine finale Methode (final void ...) kann nicht überschrieben werden. abstract und final können nicht kombiniert werden.', code: 'final class Konstante {\n    final void ausgabe() {\n        System.out.println("Nicht überschreibbar");\n    }\n}' },
  { title: 'Interface', content: 'Ein Interface ist ein Vertrag, der nur abstrakte Methoden definiert (seit Java 8 auch default-Methoden). Klassen implementieren Interfaces mit implements.', code: 'interface Fahrbar {\n    void fahren();\n    default void hupen() {\n        System.out.println("Huup!");\n    }\n}' },
  { title: 'Mehrere Interfaces implementieren', content: 'Eine Klasse kann mehrere Interfaces implementieren, aber nur eine Klasse erweitern. Interfaces können nur public static final Konstanten als Attribute haben.', code: 'class Auto implements Fahrbar, Parkbar {\n    public void fahren() { }\n    public void parken() { }\n}' },
  { title: 'Interface vs abstrakte Klasse', content: 'Abstrakte Klasse: Zustand (Attribute), Konstruktor, eine Vererbung. Interface: kein Zustand, kein Konstruktor, Mehrfachimplementierung möglich.' },
  { title: 'Diamond-Problem', content: 'Das Diamond-Problem entsteht bei Mehrfachvererbung, wenn zwei Elternklassen die gleiche Methode haben. Java vermeidet dies durch einfache Vererbung bei Klassen. Bei Interfaces mit default-Methoden muss die Klasse die Methode explizit überschreiben.' }
];

export const questions = [
  { id: 'm09q01', type: 'mc', question: 'Was ist eine abstrakte Klasse?', options: ['Eine Klasse mit mindestens einer abstrakten Methode, die nicht instanziiert werden kann', 'Eine Klasse ohne Methoden', 'Eine Klasse die nur statische Methoden hat', 'Eine finale Klasse'], answer: 'Eine Klasse mit mindestens einer abstrakten Methode, die nicht instanziiert werden kann', explanation: 'Eine abstrakte Klasse wird mit abstract deklariert, kann abstrakte Methoden enthalten und kann nicht direkt instanziiert werden.' },
  { id: 'm09q02', type: 'truefalse', question: 'Man kann eine abstrakte Klasse direkt instanziieren (new AbstrakteKlasse()).', options: ['Wahr', 'Falsch'], answer: 'Falsch', explanation: 'Abstrakte Klassen können nicht direkt instanziiert werden. Man muss eine konkrete Unterklasse erstellen.' },
  { id: 'm09q03', type: 'mc', question: 'Was ist ein Interface in Java?', options: ['Ein Vertrag, der Methoden definiert, die implementierende Klassen bereitstellen müssen', 'Eine grafische Benutzeroberfläche', 'Ein Synonym für abstrakte Klasse', 'Eine konkrete Klasse mit allen Methoden'], answer: 'Ein Vertrag, der Methoden definiert, die implementierende Klassen bereitstellen müssen', explanation: 'Ein Interface definiert einen Vertrag: welche Methoden eine Klasse implementieren muss.' },
  { id: 'm09q04', type: 'mc', question: 'Was ist der Hauptunterschied zwischen Interface und abstrakter Klasse?', options: ['Interface: kein Zustand, Mehrfachimplementierung möglich; Abstrakte Klasse: Zustand erlaubt, nur einfache Vererbung', 'Es gibt keinen Unterschied', 'Interface kann Konstruktoren haben', 'Abstrakte Klasse kann keine Methoden haben'], answer: 'Interface: kein Zustand, Mehrfachimplementierung möglich; Abstrakte Klasse: Zustand erlaubt, nur einfache Vererbung', explanation: 'Interfaces haben keinen Zustand und erlauben Mehrfachimplementierung. Abstrakte Klassen können Zustand haben, aber nur einfache Vererbung.' },
  { id: 'm09q05', type: 'mc', question: 'Was bedeutet final bei einer Klasse?', options: ['Die Klasse kann nicht erweitert (vererbt) werden', 'Die Klasse ist abstrakt', 'Die Klasse hat keine Methoden', 'Die Klasse ist privat'], answer: 'Die Klasse kann nicht erweitert (vererbt) werden', explanation: 'Eine final class kann nicht als Superklasse verwendet werden – keine Vererbung möglich.' },
  { id: 'm09q06', type: 'mc', question: 'Was bedeutet final bei einer Methode?', options: ['Die Methode kann nicht überschrieben werden', 'Die Methode ist abstrakt', 'Die Methode gibt immer null zurück', 'Die Methode ist statisch'], answer: 'Die Methode kann nicht überschrieben werden', explanation: 'Eine final-Methode kann in Unterklassen nicht überschrieben (@Override) werden.' },
  { id: 'm09q07', type: 'truefalse', question: 'Eine abstrakte Klasse kann sowohl abstrakte als auch konkrete (implementierte) Methoden haben.', options: ['Wahr', 'Falsch'], answer: 'Wahr', explanation: 'Ja, das ist ein Vorteil abstrakter Klassen: sie können gemeinsame Implementierungen bereitstellen und gleichzeitig abstrakte Methoden erzwingen.' },
  { id: 'm09q08', type: 'mc', question: 'Welche Art von Attributen kann ein Interface haben?', options: ['Nur public static final Konstanten', 'Beliebige Instanzvariablen', 'Private Attribute', 'Gar keine Attribute'], answer: 'Nur public static final Konstanten', explanation: 'Interface-Attribute sind implizit public static final – also Konstanten.' },
  { id: 'm09q09', type: 'truefalse', question: 'Eine Klasse kann mehrere Interfaces gleichzeitig implementieren.', options: ['Wahr', 'Falsch'], answer: 'Wahr', explanation: 'Ja, mit Komma getrennt: class X implements A, B, C { }' },
  { id: 'm09q10', type: 'truefalse', question: 'Eine Klasse kann mehrere Klassen gleichzeitig erweitern (extends).', options: ['Wahr', 'Falsch'], answer: 'Falsch', explanation: 'Java erlaubt nur einfache Vererbung bei Klassen. Eine Klasse kann nur eine Superklasse haben.' },
  { id: 'm09q11', type: 'mc', question: 'Was sind default-Methoden in Interfaces?', options: ['Methoden mit einer Standardimplementierung im Interface', 'Private Methoden', 'Abstrakte Methoden', 'Statische Methoden'], answer: 'Methoden mit einer Standardimplementierung im Interface', explanation: 'Seit Java 8 können Interfaces default-Methoden mit Implementierung haben.' },
  { id: 'm09q12', type: 'mc', question: 'Was ist die Ausgabe?', code: 'abstract class Form {\n    abstract double flaeche();\n}\nclass Kreis extends Form {\n    double radius = 5;\n    double flaeche() {\n        return Math.PI * radius * radius;\n    }\n}\nForm f = new Kreis();\nSystem.out.println(f.flaeche() > 0);', options: ['true', 'false', 'Kompilierfehler', 'Laufzeitfehler'], answer: 'true', explanation: 'Kreis implementiert flaeche(). Das Ergebnis ist PI*25 ≈ 78.5, also > 0 → true.' },
  { id: 'm09q13', type: 'mc', question: 'Was ist die Ausgabe?', code: 'interface Begruessung {\n    String gruss();\n}\nclass Deutsch implements Begruessung {\n    public String gruss() {\n        return "Hallo";\n    }\n}\nBegruessung b = new Deutsch();\nSystem.out.println(b.gruss());', options: ['Hallo', 'null', 'Kompilierfehler', 'Laufzeitfehler'], answer: 'Hallo', explanation: 'Die Klasse Deutsch implementiert das Interface korrekt. gruss() gibt "Hallo" zurück.' },
  { id: 'm09q14', type: 'mc', question: 'Was ist das Diamond-Problem?', options: ['Mehrdeutigkeit bei Mehrfachvererbung, wenn gleiche Methode in mehreren Elternklassen existiert', 'Ein Fehler beim Kompilieren von Interfaces', 'Ein Problem mit Diamant-Operatoren (<>)', 'Ein Fehler bei final-Klassen'], answer: 'Mehrdeutigkeit bei Mehrfachvererbung, wenn gleiche Methode in mehreren Elternklassen existiert', explanation: 'Das Diamond-Problem tritt auf, wenn eine Klasse von zwei Klassen erbt, die die gleiche Methode haben. Java vermeidet dies durch einfache Vererbung.' },
  { id: 'm09q15', type: 'truefalse', question: 'Eine Klasse kann gleichzeitig abstract und final sein.', options: ['Wahr', 'Falsch'], answer: 'Falsch', explanation: 'abstract bedeutet "muss erweitert werden", final bedeutet "kann nicht erweitert werden" – ein Widerspruch.' }
];
